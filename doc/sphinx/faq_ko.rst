자주 묻는 질문
==========================

.. epigraph::

   | **토비 경:** 가장 절묘한 이유가 무엇인가, 친애하는 기사?
   | **앤드류 경:** 절묘한 이유는 없지만,
   | 충분히 좋은 이유는 있네.

   -- 십이야, II, iii, 130 -- 셰익스피어


(또는 지금까지 받은 많은 질문들)


FontForge에 대한 일반적인 질문
---------------------------------

* :ref:`왜 폰트 편집기인가요? 이미 폰트가 충분하지 않나요? <faq.font-editor>`

  * :ref:`왜 제가 만들었을까요? <faq.write>`
  * :ref:`왜 무료로 제공하나요? <faq.give>`
  * :ref:`FontForge 작업이 도자기를 만들거나 빵을 굽는 것과 같은 즐거움을 주나요? <faq.Pots>`
  * :ref:`왜 네이티브 MS Windows나 Mac 윈도우 시스템을 사용하지 않나요? <faq.native>`
  * :ref:`왜 FontForge는 비표준 위젯 세트를 기반으로 하나요? <faq.widget-set>`
  * :ref:`왜 FontForge는 C++로 작성되지 않았나요? (또는 왜 C++가 제가 가장 좋아하는 언어가 아닌가요?) <faq.C-plus-plus>`
  * :ref:`왜 FontForge를 BSD 라이선스가 아닌 GPL로 출시하나요? <faq.bsd-license>`
  * :ref:`왜 FontForge는 라이브러리와 링크되지 않고 런타임에 로드하나요? <faq.libraries>`
  * :ref:`왜 FontForge에 대한 향후 로드맵이 없나요? <faq.roadmap>`


폰트에 대한 일반적인 질문
-----------------------------

* :ref:`폰트를 수정하는 것이 합법적인가요? 윤리적인가요? <faq.legal>`
* :ref:`12포인트 폰트란 무엇인가요? <faq.pointsize>` (폰트의 어떤 측정값이 포인트 크기를 결정하나요?)

  * :ref:`폰트의 줄 간격을 어떻게 설정하나요? <faq.linespace>`
* :ref:`내 글리프는 얼마나 커질까요? (em-unit이란 무엇인가요?) <faq.em-units>`
* :ref:`오픈 소스 폰트에 사용하기 좋은 라이선스는 무엇인가요? <faq.license>`


FontForge 사용 및 다양한 시스템에 폰트 설치하기
-----------------------------------------------------

* `FontForge를 어떻게 설치하나요? <https://fontforge.org/en-US/downloads/>`__
* :ref:`최소 요구 사항 <faq.Minimum>`

  * :ref:`왜 FontForge는 메모리를 많이 사용하나요? <faq.excessive-memory>`
* :ref:`만든 폰트를 어떻게 설치하나요? <faq.font-install>`
* :ref:`왜 FontForge 폰트가 일부 MS Windows 시스템에 설치되지 않나요? <faq.Bad-Windows-Install>`
* :ref:`Mac에서 폰트를 어떻게 편집하나요? <faq.How-mac>`

  * :ref:`Mac 폰트 패밀리를 어떻게 만드나요? (Mac에서 이탤릭 및 볼드 스타일이 작동하도록 폰트를 그룹화하려면 어떻게 해야 하나요?) <faq.How-family>`
  * :ref:`왜 ATM이 제 폰트에서 작동하지 않나요? <faq.Mac-ATM>`
* :ref:`MS Windows에서 폰트를 어떻게 편집하나요? <faq.windows>`

  * :ref:`왜 제 폰트가 Windows에서 작동하지 않나요? <faq.Bad-Windows-Fonts>`
* :ref:`Opentype(또는 truetype) 폰트를 생성했는데 Windows에서 설치되지 않았습니다. 왜 그런가요? <faq.otf-diffs>`
* :ref:`Opentype 테이블이 있는 truetype 폰트가 있는데 Windows에서 "O" 아이콘이 아닌 "TT"(truetype) 아이콘을 표시합니다. 왜 그런가요? <faq.DSIG>`
* :ref:`다양한 폰트 이름은 무엇을 의미하나요? <faq.names>`


폰트 변환
----------------

* :ref:`한 아웃라인 형식에서 다른 형식으로 변환하기 <faq.outline-conversion>`
* :ref:`한 비트맵 형식에서 다른 형식으로 변환하기 <faq.bitmap-conversion>`
* :ref:`아웃라인 형식에서 비트맵으로 변환하기 <faq.outline-bitmap>`
* :ref:`비트맵 형식에서 아웃라인으로 변환하기 <faq.bitmap-outline>`
* :ref:`Apple의 고급 타이포그래피에서 OpenType으로 변환하기 <faq.AAT2OT>`
* :ref:`OT에서 AAT로 변환하기 <faq.OT2AAT>`
* :ref:`Inkscape에서 글리프 가져오기 <faq.Inkscape>`


힌트 및 TrueType 지침에 대한 질문
-----------------------------------------------

* :ref:`힌트 대체를 사용하려면 어떻게 해야 하나요? <faq.hint-subs>`
* :ref:`flex 힌트를 사용하려면 어떻게 해야 하나요? <faq.flex-hints>`

  * :ref:`flex 힌트를 사용할지 어떻게 알 수 있나요? <faq.flex2>`
* :ref:`제 글리프는 모두 완벽하게 힌트 처리되었는데 왜 일부 스템의 너비가 다르거나(또는 흐릿하게 보이거나 완전히 사라지나요)? <faq.fuzzy>`
* :ref:`ttf 폰트를 로드하고 몇 가지 변경한 후 새 폰트를 생성했습니다. 변경된 글리프가 원본만큼 보기 좋지 않습니다. 왜 그런가요? <faq.ttf-degrade>`


:doc:`폰트 형식 </appendices/bibliography>`에 대한 질문
--------------------------------------------------------------

* :ref:`OpenType과 PostScript(또는 TrueType) 폰트의 차이점은 무엇인가요? <faq.Open-difference>`
* :ref:`AAT(Apple Advanced Typography)와 OpenType의 차이점은 무엇인가요? <faq.AAT-Open>`
* :ref:`10.3에서 잘 작동하던 폰트가 Mac 10.4(Tiger)에서 실패하는 이유는 무엇인가요? <faq.Tiger-Open>`
* :ref:`cidmap 파일은 도대체 무엇이며, 신경 써야 하나요? <faq.cidmaps>`

  * :ref:`(CID 키 폰트란 무엇인가요?) <cidmenu.CID>`
* :ref:`왜 TeX가 제 폰트에서 작동하지 않나요? <faq.TeX>`

  * :ref:`왜 FontForge에서 '.mf' 파일을 편집할 수 없나요? <faq.mf-files>`
* :ref:`정수가 아닌 좌표를 사용해도 안전한가요? Word나 다른 프로그램에서 문제가 발생하지 않을까요? <faq.non-integral>`
* :ref:`왜 제 Open Type 폰트가 .pfb 파일보다 훨씬 작지 않나요? <faq.Open-size>`
* :ref:`otf 또는 type1 폰트를 로드하면 대부분의 참조가 인라인 복사본으로 대체되었습니다. 참조를 다시 가져오려면 어떻게 해야 하나요? <faq.Missing-Refs>`
* :ref:`FontForge는 폰트에서 이전 커닝 정보를 읽어오나요? <faq.kern-info>`
* :ref:`OS/2 테이블(또는 다른 테이블)의 특정 비트를 어떻게 설정하나요? <faq.mensis>`
* :ref:`sfd 파일이란 무엇인가요? <faq.sfd>`

  * :ref:`왜 그렇게 큰가요? <faq.excessive-memory>`


수학적 질문
----------------------

* :ref:`단순화 명령이 정확도를 잃나요? <faq.simplify>`
* :ref:`FontForge는 3차 스플라인을 truetype용 2차 스플라인으로 어떻게 변환하나요? <faq.cubic-quadratic>`
* :ref:`FontForge는 2차 스플라인을 3차로 어떻게 변환하나요(truetype 읽을 때)? <faq.quadratic-cubic>`


이미지 파일 질문
--------------------

* :ref:`왜 fontforge가 "EPS 파일이 너무 복잡해서 이해할 수 없습니다"라고 말하나요? <faq.complex-eps>`
* :ref:`Inkscape에서 글리프 가져오기 <faq.Inkscape>`


기타 질문
----------------

* :ref:`FontForge의 회색 배경이 마음에 들지 않습니다. 어떻게 변경하나요? <faq.background>`
* :ref:`FontForge가 GUI에서 사용하는 폰트가 너무 작습니다(너무 큽니다). 어떻게 변경하나요? <faq.fontsize>`
* :ref:`폰트를 고정 폭으로 어떻게 표시하나요? <faq.monospace>`
* :ref:`fontforge에 새 인코딩을 어떻게 알리나요? <faq.new-encoding>`
* :ref:`새 이름으로 글리프를 어떻게 추가하나요? <faq.new-name>`
* :ref:`왜 fontforge가 일부 글리프에 잘못된 이름을 부여하나요? <faq.glyphnames>`
* :ref:`폰트를 생성하고 종료한 후 왜 FontForge가 폰트를 저장할지 묻나요? 아무것도 변경하지 않았습니다. <faq.save-no-change>`
* :ref:`뷰를 최소화하려고 할 때 왜 창이 아이콘화되나요? <faq.minify-iconify>`
* :ref:`왜 제 그리스어 폰트에 "mu"라는 문자가 없나요? <faq.no-mu>` (또는
  "Delta", 또는 "Omega", 또는 "pi1")
* :ref:`왜 편집->복사가 글리프 정보뿐만 아니라 글리프 이름도 복사하지 않나요? <faq.no-copy-names>`
* :ref:`왜 편집->붙여넣기가 이름 중복에 대해 불평하나요? <faq.copy-names>`
* :ref:`왜 요소->빌드->강조된 글리프 빌드가 비활성화(또는 회색)되어 있나요? <faq.disabled-build-menu>`
* :ref:`폰트의 기본 글리프를 어떻게 설정하나요? <faq.default-char>`
* :ref:`kaiu.ttf 또는 mingliu.ttf를 봤는데 외곽선이 올바른 글리프와 전혀 닮지 않았습니다. 무엇이 잘못되었나요? <faq.mingliu>`
* :ref:`요소->빌드->강조된 글리프 빌드를 사용하여 확장 그리스 글리프(U+1F00-U+1FFF) 중 하나를 빌드할 때 FontForge가 잘못된 강조를 선택합니다. 왜 그런가요? <faq.greek-accents>`
* :ref:`요소->빌드->강조된 글리프 빌드를 사용하여 "u" 또는 "y" 위에 강조를 빌드할 때 글리프 중앙이 아닌 스템 중 하나 위에 강조가 표시됩니다. 왜 그런가요? <faq.u-accents>`
* :ref:`요소->겹침->겹침 제거를 사용할 때 겹치는 부분에서 글리프가 반전(또는 흰색)됩니다. 왜 그런가요? <faq.remove-overlap>`
* :ref:`왜 ttf2afm이 FontForge ttf 파일에서 충돌하나요? <faq.ttf2afm>`
* `FontForge의 알려진 버그 목록은 어디에서 찾을 수 있나요? <https://github.com/fontforge/fontforge/issues>`__
* :ref:`FontForge가 메모리 부족으로 계속 충돌합니다. 어떻게 해야 하나요? <faq.memory>`
* :ref:`왜 FontForge는 그렇게 불안정한가요? <faq.Unstable>`
* :ref:`왜 FontForge는 Xgl/Compiz에서 보기 흉하게 보이나요? <faq.Compiz>`
* :ref:`왜 제가 컨퍼런스에서 발표하지 않나요? <faq.talk>`

--------------------------------------------------------------------------------

.. _faq.font-editor:

.. epigraph::

   | 하지만 이요르는 혼잣말을 하고 있었다.
   | "이 글쓰기 사업. 연필
   | 그리고 기타 등등. 과대평가되었어, 내 생각엔.
   | 어리석은 짓이야. 아무것도 없어."

   -- 곰돌이 푸 -- A.A. 밀른


**왜 폰트 편집기인가요? 이미 폰트가 충분하지 않나요?**
   음... 아니요. 그렇지 않으면 제가 이걸 쓰고 있지 않을 것이고, 더 중요한 것은
   매달 수천 명의 사람들이 다운로드하지 않을 것입니다.

   저는 이 질문을 자주 받습니다. 저에게 이것은 오해를 나타냅니다. 당신은
   붓 제조업자에게 가서 수채화가 이미 충분하다고 생각하는지 묻지 않을 것입니다.
   폰트는 예술 작품이며 제작자의 개인적인 천재성을 나타냅니다. 수채화보다 더
   잉여적이지 않습니다.

   그러나 질문을 액면 그대로 받아들이고, 여기에 대한 제 대답을 시도해 보겠습니다...
   실용적으로.

   #. 라틴어 폰트가 많이 있습니다. 그리스어, 키릴 자모, 인도어,
      태국어, 중국어, 일본어, 한국어, 유니코드 폰트는 훨씬 적습니다...
   #. 좋은 품질의 무료 폰트가 많지 않습니다.
   #. 오래된 문자 체계를 연구하는 연구자들은 종종 자신의 폰트를 디자인해야 합니다.
   #. 라틴어의 경우에도 전통적으로 각 새로운 예술 및 건축 양식에는
      관련된 폰트 스타일이 있습니다. 시대의 미학을 반영하기 위해 항상 새로운 폰트가
      만들어지고 있습니다.
   #. 컴퓨터 폰트 기술은 끊임없이 변화하고 있습니다. 10년 전에 유용했던 폰트 형식은
      지금은 그렇지 않을 수 있습니다.
   #. 존재하는 폰트에 만족하더라도 완전하지 않을 수 있습니다.

      * 누락된 합자
      * 누락된 악센트 부호
      * 일치하는 키릴 자모 또는 그리스어 글리프 없음
   #. 모든 사람은 자신의 필체로 된 폰트를 원합니다.
   #. 폰트로 노는 것은 재미있습니다.

   FontForge는 단순히 폰트를 만들고 수정하는 것 이상의 용도가 있습니다.
   한 형식에서 다른 형식으로 변환할 수 있습니다. 폰트 파일에서 정보를 추출할 수 있습니다.
   또는 설치하지 않고도 폰트가 어떻게 생겼는지 보여줄 수 있습니다.

.. _faq.write:

**왜 제가 만들었을까요?**
   .. epigraph::

      왜 안 되겠어?

      -- 팬텀 톨부스 -- 저스터

   * 재미있었기 때문에
   * MacroMedia가 Fontographer 개발을 중단했고, Fontographer에는
     제가 원했던 기능이 부족했기 때문에
   * 배우기 위해

   자세한 내용은 :doc:`FontForge 역사 </appendices/ff-history>`
   페이지를 참조하십시오.

.. _faq.give:

**왜 무료로 제공하나요?**
   * 저는 무료 소프트웨어를 지지하며 좋은 운영 체제에서 좋은 제품을 사용할 수 있게 되면
     사람들이 독점 시스템을 사용하지 않도록 장려할 것이라고 희망하기 때문입니다.
   * 프로그래밍은 마케팅보다 훨씬 재미있고 물건을 주는 것이
     파는 것보다 쉽기 때문입니다.
   * 팔면 QA에 더 많은 시간을 할애해야 하기 때문입니다(그리고 QA는 별로 재미없습니다).

.. _faq.native:

**왜 네이티브 MS Windows나 Mac 윈도우 시스템을 사용하지 않나요?**
   * FontForge는 상용 제품이 아니며 시장의 제약에 얽매이지 않습니다.
   * 그 포팅은 제게 흥미롭지 않습니다.
   * 그 작업을 맡을 시간도 기술도 없습니다.
   * 사람들이 Linux/Unix를 사용하도록 장려하고 싶습니다.

   물론, 제가 :ref:`gtk나 qt <faq.widget-set>` 중 하나를 사용한다면 포팅의
   어려움 중 일부는 사라질 것입니다. 하지만 불행히도 저는 그 위젯 세트들을
   좋아하지 않습니다.

   이제... *당신*이 포팅을 하고 싶다면, 정말 멋질 것입니다.
   그렇게 하도록 권장합니다.

.. _faq.widget-set:

**왜 FontForge는 비표준 위젯 세트를 기반으로 하나요?**
   저는 유니코드를 합리적으로 잘 처리할 수 있는 위젯 세트를 원했습니다.
   특히 히브리어와 아랍어 타이포그래피에 bidi 텍스트 지원이 중요하다고
   생각했습니다. 그렇게 하는 위젯 세트를 알지 못했기 때문에 제 것을
   직접 만들었습니다.

   저는 또한 체크박스가 체크되었는지 아닌지 실제로 알아낼 수 있는
   위젯 세트를 원했습니다. 너무 많은 경우에 제 눈으로는 어느 것이
   어느 것인지 구분할 수 없습니다... (아이러니하게도 제가 가장 자주 받는 불만은
   제 체크박스가 체크되었는지 알 수 없다는 사람들로부터입니다.
   이것을 어떻게 받아들여야 할지 모르겠습니다.)

   이제 저는 제 것보다 유니코드 지원이 훨씬 뛰어난 두 가지 무료 위젯 세트가
   있다는 것을 깨달았습니다. 바로
   `QT <http://www.trolltech.com/developer/downloads/qt>`__와
   `gtk <http://www.gtk.org/>`__입니다. 저는 여전히 둘 다 사용하지 않습니다. 왜냐하면:

   * 한 위젯 세트에서 다른 위젯 세트로 변환하는 것은 지루합니다. 그리고 사람들이 저에게
     버그를 보내서 제 주의를 산만하게 합니다.
   * 그 변환에 시간을 쓴다면 FontForge를 더 기능적으로 만들지
     못할 것입니다.
   * QT는 C++로 작성되었고, :ref:`아래에서 설명하듯이 <faq.C-plus-plus>`, 저는
     C++를 좋아하지 않으므로 제외합니다.
   * gtk를 볼수록 마음에 들지 않습니다.

     * 이미지 지원이 형편없습니다(gimp용으로 작성되었기 때문에 이상합니다).

       * 클라이언트 측 비트맵에 대한 지원이 전혀 없습니다(그리고 저는 비트맵 폰트를
         지원하고 싶습니다).
       * 인덱스 이미지의 색상표에서는 색상이 RGB 순서이지만 24비트
         색상 이미지에서는 BGR 순서입니다.
       * 간단한 비트맵을 그리고 싶을 때 전체 RGBA 이미지를 사용하지 않고는
         투명 이미지를 간단하게 지원할 수 없습니다. 이는 약간 과도합니다.
       * 이미지에 대한 포괄적인 형식이 없어서 이미지 자체가
         비트맵인지, 인덱스인지, 트루컬러인지 알 수 없습니다.
       * 이것들을 고치는 것은 가능했지만, 제 쪽에서 매우 낮은 수준의 작업이 많이
         필요했습니다 -- 그리고 저는 X에서만 그 작업을 할 수 있습니다.
     * 파일 선택기 대화 상자가 정말 못생겼습니다. 그리고 너무 복잡해서
       제가 보기 좋게 수정하는 방법을 알아낼 수 없습니다(제 기준으로는요).
     * 또한 fontforge의 파일 선택기가 현재 동작하는 방식(폰트 파일 위로
       마우스를 움직이면 폰트 이름이 표시되는 팝업 창, 파일 이름 입력 상자에
       첨부된 최근 사용 파일의 드롭다운 목록 등)으로 동작하도록 파일 선택기를
       수정하는 방법을 알아낼 수 없습니다.
     * gtk+2는 Mac OS에서 기본적으로 실행되지 않으며, gtk를 Mac으로 이식하는
       유일한 사람들은 gtk-1에서 작업하는 것 같습니다.
     * 제가 사용하고 싶은 많은 위젯이 더 이상 사용되지 않습니다. 때로는 무엇이
       그것들을 대체하는지 알아낼 수 없고, 때로는 훨씬 더 복잡한 위젯을
       사용해야 합니다.
     * 그래서 저는 그것과 씨름하다가 결국 제 현재 위젯이 더 낫다고
       결정하는 경향이 있습니다.
     * gtk에서 fontforge의 제한된 버전을 실행하는 데 성공했습니다. 다른 사람이
       그것을 확장하고 유지 관리해 주시면 감사하겠습니다.

.. _faq.C-plus-plus:

**왜 FontForge는 C++로 작성되지 않았나요? (또는 *왜 C++는 제가 가장 좋아하는 언어가 아닌가요*)?**
   이 질문을 받고 조금 놀랐습니다. 제 언어 선택에 정당화가 필요하다는 것을
   깨닫지 못했지만, 그렇게 해야 할 것 같습니다...

   기본적으로 저는 대부분의 경우 객체 지향 방식이 도움이 되지 않는다고 생각하고,
   C++가 너무 복잡하고 잘못 설계되었다고 생각하며, 쉽게 디버깅할 수 없기 때문입니다.

   * 저는 SIMULA로 자랐고 SmallTalk를 조금 다루어 보았는데, 몇 년 후에
     객체 지향 접근 방식이 자연스럽게 느껴지는 문제는 거의 없다는 것을
     알게 되었습니다. 대부분의 경우 문제에 불필요한 복잡성을 부과하는 것 같았습니다.
   * C++ 프로그램의 의미론은 지정할 수 없습니다. 컴파일러는 원하는 대로
     임시 변수를 자유롭게 생성할 수 있습니다. C에서는 이것이 문제가 되지 않지만, C++에서는
     임시 변수를 생성하면 생성자와 소멸자를 호출하게 되어
     말할 수 없는 부작용을 일으킬 수 있습니다. 저는 이것이 무섭습니다.
   * 외부 생성자의 실행 순서는 지정되지 않았습니다. 저는 이로 인해
     많은 설명할 수 없는 버그를 보았습니다.
   * C++를 디버깅하는 것이 매우 어렵습니다. 문장을 단계별로 실행하면
     예상치 못한 많은 프로시저 호출이 발생합니다(일부는 인라인되어
     명확하지 않습니다). 이것은 디버깅의 주요 목적에서 저를 산만하게 합니다.
   * 마지막으로 저는 이 언어가 잘못 지정되었고 너무 복잡하다고 생각합니다.
     다양한 개념이 잘 어울리지 않습니다. 각 컴파일러는 약간씩 다르게
     작동하는 것 같습니다.

     저는 1981년경에 C with Classes라고 불릴 때 C++를 처음 만났습니다. 저는
     1987년부터 1994년까지 Green Hills Software의 컴파일러 제품군용 C++
     프런트엔드를 작성했으며 1.1부터 ANSI까지 각 새 버전의 언어를
     추적했습니다.

     각 버전은 기존 버전과 잘 어울리지 않는 새로운 기능을 추가했습니다.
     각 버전은 잘못 지정되었습니다. 참조 구현은 사양과 크게
     달랐습니다. 예를 들어 생성자 내 가상 함수의 동작은
     언어의 버전 2까지 지정되지 않았으며 이 동작이 순진한
     기대와 달랐기 때문에 버그가 발생했습니다. 제가 가장 좋아하는 혼란은
     (제가 생각하기에) 버전 2.1 사양에서 발생했는데, 한 페이지에서 몇 단락
     내에 다음과 같은 두 문장이 있었습니다. "공용체는 멤버 함수를 포함할 수
     있습니다."와 "공용체는 멤버 함수를 포함할 수 없습니다."

   위의 내용은 제 경험에 근거한 개인적인 의견이며 *제가* C++를 사용하지 않는
   이유를 설명합니다. 당신의 의견은 아마 다를 것입니다. 5년 동안 C++ 컴파일러를
   작성한 사람은 거의 없습니다.

.. _faq.bsd-license:

**왜 FontForge를 GPL이 아닌 BSD 라이선스로 출시하나요?**
   저는 그냥 GPL을 좋아하지 않습니다. 부분적으로는 편견이고, 부분적으로는 실제입니다.

   사람들에게 제한을 강요하는 것을 좋아하지 않습니다.

   저는 fontforge를 무료로 제공하고 있습니다.

   `BSD 라이선스 <https://raw.githubusercontent.com/fontforge/fontforge/master/LICENSE>`__는
   "저를 고소하지 말고, 제 코드를 사용하면 제 저작권 고지를 포함하세요"라고
   말하며, 그것이 제가 신경 쓰는 전부입니다.

   아마도 제가 순진할지 모르지만, 누군가가 fontforge를 팔기 시작할 것이라고
   믿지 않습니다. 왜 그럴까요? 제가 무료로 주는 것을 누군가가 팔려고 하는 것은
   말이 되지 않습니다. 그들이 fontforge에 기능을 추가한다면, 그것은 다른
   문제이지만, 어떤 의미에서는 fontforge에 대해 요금을 부과하는 것이 아니라,

   그들이 추가한 코드에 대해 요금을 부과하는 것입니다. 누군가가 그렇게 한다면
   짜증나겠지만, 제 눈에는 좀 무례하지만, "안돼"라고 말하지는 않을 것입니다.

   이제 누군가가 fontforge의 작은 부분을 가져다가 다른 것에 사용할 수 있습니다.
   그것은 저를 귀찮게 하지 않습니다. 제 OpenType 코드 중 일부가 일부 TeX
   패키지에 의해 도용되었다는 것을 알고 있습니다. 그리고 저는 일부 다른 패키지에서
   체크섬을 생성하는 코드를 도용했습니다.

   저는 다른 사람들을 돕는 것을 좋아합니다. 그리고 사람들이 저를 도와주었습니다.

.. _faq.libraries:

**왜 FontForge는 라이브러리와 링크되지 않고 런타임에 로드하나요?**
   저는 의존성을 싫어합니다. 적을수록 좋습니다.

   패키지를 다운로드했는데 다른 패키지 6개를 다운로드하지 않으면 작동하지 않는다는
   것을 발견했을 때 정말 싫습니다(차례로 더 많은 패키지를 다운로드해야 할 수도
   있습니다).

   패키지를 다운로드하고 그냥 작동하기를 원합니다.

   그래서 저는 가능한 한 많은 코드를 직접 작성하고 모든 것을 한 덩어리로
   릴리스하여 사람들이 웹을 헤매며 다른 부분을 찾도록 강요하지 않으려고
   합니다.

   스스로 할 수 없는 방법을 찾을 수 없을 때, 필요한 경우 외부 라이브러리를
   사용합니다. 그때에도 시스템에 라이브러리가 없어도 fontforge가 실행되도록
   하려고 합니다. 바이너리 패키지를 릴리스할 때 5개의 다른 라이브러리가
   있거나 없을 가능성에 따라 호스트당 32개의 패키지를 릴리스하고 싶지
   않습니다. 하지만 fontforge를 시작하기 위해 결코 사용하지 않을 라이브러리를
   누군가에게 설치하도록 강요하고 싶지도 않습니다.

   사용자가 svg 글리프를 절대 보지 않을 것이라면 libxml2를 설치할 필요가
   없습니다. 사용자가 jpeg 이미지를 절대 가져오지 않을 것이라면(그리고
   그렇게 할 이유가 정말 없습니다) libjpeg를 설치할 필요가 없습니다.

   대신, 제가 릴리스하는 바이너리는 *필요할 때* 라이브러리를 동적으로 로드(dlopen)하려고
   하며 그 전에는 로드하지 않습니다. 이것은 또한 fontforge 시작 속도를 높일 것입니다.
   시스템에 라이브러리가 있으면 모든 것이 행복하고 좋습니다. 라이브러리가 없으면
   그 기능은 손실되지만 나머지 fontforge는 계속 작동합니다.

.. _faq.roadmap:

**왜 FontForge에 대한 향후 로드맵이 없나요?**
   .. epigraph::

      | **타이슨:**
      | 저는 당황하지 않았습니다. 당황하지 않았다고
      | 장담합니다. 사실 계획이
      | 거의 확실하게 제 머릿속에서 형성되고 있습니다.
      | 바로 이 순간에 말입니다. 적절할 수도 있습니다.

      -- *The Lady's not for Burning* -- 크리스토퍼 프라이

   주로 제가 그런 식으로 생각하지 않기 때문입니다. 저는 계획을 세우지 않고,
   가고 싶은 곳에 대한 막연한 아이디어를 가지고 그 방향으로 탐험합니다.

   파이썬 스크립팅을 생각해 보십시오. 저는 fontforge에 파이썬을 추가하기로
   결정했습니다. 그것은 사용자가 가져오기/내보내기 파일 형식을 추가하기 위해
   자신의 스크립트를 만들 수 있는 메커니즘을 설계하는 것이 더 쉬워진다는 것을
   의미했습니다. 그리고 시작 스크립트와 특정 표준 "이벤트"가 발생했을 때의
   스크립트. 그리고 나서 사용자가 자신의 메뉴 항목을 정의할 수 있도록 할 수
   있었습니다. 그리고 나서 저는 fontforge를 파이썬에 추가하는 방법을
   알아냈습니다(그 반대가 아니라). 그리고 이제 저는 사람들이 C 프로그램 내에서
   fontforge를 라이브러리로 호출할 수 있도록 c-바인딩 세트를 정의할 수 없는
   이유가 없다는 것을 깨달았습니다. 그리고 그것이 어디로 이어질지 누가 알겠습니까
   -- 어디로든.

   각 단계는 제가 조금 더 멀리 볼 수 있고, 조금 더 멀리 갈 수 있고,
   그리고 조금 더 볼 수 있다는 것을 의미합니다.

   그리고 종종 아이디어는 사용자로부터 나옵니다. 누군가가 제가 생각하지 못했던
   기능을 요청할 것입니다.

   저는 한동안 그런 페이지를 유지했습니다. 제가 쓴 것의 절반은 결코 일어나지
   않았고, 대부분의 경우 저는 페이지를 업데이트하는 것을 귀찮아했습니다.
   잊어버리곤 했습니다. 지루했습니다. 제가 추측하지 않았다면 무엇을 할지에
   대해 단순히 추측하는 것보다 *하는* 것이 훨씬 낫습니다.

   그러니 다음에 무슨 일이 일어날지 묻지 마세요. 저도 모르니까요. 모험입니다.
   우리는 그냥 기다려 봐야 합니다.

.. _faq.Pots:

**FontForge 작업이 도자기를 만들거나 빵을 굽는 것과 같은 즐거움을 주나요?**

   .. image:: /images/bowlweb.gif
      :align: right

   2007년
   `LGM <http://www.libregraphicsmeeting.org/>`__에서 한
   `오픈 소스 퍼블리싱 <http://ospublish.constantvzw.org/?p=221>`__과의
   인터뷰에서

   저는 물건 만드는 것을 좋아합니다. 어떤 이상한 정의로는 아름다운
   물건 만드는 것을 좋아합니다. 그것이 빵 만드는 데 어떻게 적용되는지는
   확실하지 않지만, 제 도자기 -- 저는 아름다운 도자기를 만든다고 생각합니다.
   그리고 저는 그 위에 바르는 유약을 정말 좋아합니다.

   폰트 편집기가 아름답다고 말하기는 더 어렵습니다. 하지만 그 뒤에 있는
   아이디어는 제 마음속에서 아름답다고 생각합니다 -- 그리고 어떤 의미에서는
   *제가* 사용자 인터페이스가 아름답다고 생각합니다. 세상의 다른 누구도
   그렇게 생각하는지는 확실하지 않습니다. 왜냐하면 그것은 제가 원하는 것이기
   때문이지만, 저는 그것이 아름답다고 생각합니다.

   그리고 무언가를 만드는 데 -- 아름다운 것을 만드는 데 만족감이 있습니다.

   그리고 (빵에 관한 한) 제가 필요한 것을 만드는 데도 만족감이 있습니다.
   저는 제 빵을 먹습니다 -- 제가 먹는 빵은 그것뿐입니다.

   그래서 그냥 -- 저는 아름다운 것을 만드는 것을 좋아합니다.

.. _faq.legal:

**폰트를 수정하는 것이 합법적인가요? 윤리적인가요?**
   많은 현재 폰트는 수 세기 전의 위대한 디자이너들의 작품을 기반으로
   합니다 -- 그래서 다른 사람의 디자인을 재사용하는 것은 오랜 역사를 가지고
   있습니다. 반면에 법이 어떻든 간에 살아있는 디자이너의 작품을 훔치는 것은
   분명히 비윤리적입니다.

   법적인 문제는 국가마다 다릅니다(그리고 국가 내에서도 다를 수 있습니다).
   확실한 답변을 위해서는 변호사와 상담해야 합니다. 다음은 몇 가지
   지침입니다.

   폰트와 함께 받은 라이선스 계약을 보고 이 문제에 대해 무엇을 말하는지
   확인하십시오.

   TrueType(및 OpenType 및 잠재적으로 CID 키 폰트)에는
   OS/2 테이블에 FSType이라는 필드가 있어 폰트 디자이너가 다른 사람이
   폰트로 할 수 있는 일에 제한을 둘 수 있습니다. 이 필드가 수정을
   금지하면 fontforge는 이 필드를 대체하는 폰트 디자이너와의 계약이
   있는지 확인하도록 요청할 것입니다.

   제가 이해하는 미국 법(하지만 이에 의존하기 전에 변호사와 확인하십시오)은
   다음과 같습니다.

   * 폰트 디자인에 대한 법적 보호는 최소한입니다. 오래 전에 어떤 법적 인물이
     "알파벳은 공공의 것이다"라고 주장했습니다. 이것은 타입 디자인이
     저작권으로 보호될 수 없다는 것을 의미했습니다.

     그러나 (제가 들은 바로는) 디자이너는 14년 동안 디자인을 보호하는
     디자인 특허를 (정부에) 등록할 수 있습니다(허가된 경우). 갱신할 수
     없다고 생각하지만 틀릴 수도 있습니다.

     특허 등록은 비싸고 시간이 많이 걸리는 과정이며 종종
     작은 디자인 회사의 능력을 벗어납니다. 제가 아는 한 이 법은
     미국에서 한 번도 테스트된 적이 없으므로 보호가 의심스러울 수 있습니다.
   * 폰트 *프로그램*(예: 포스트스크립트 또는 트루타입 폰트 파일, 비트맵
     폰트 파일은 아님)은 저작권으로 보호될 수 있습니다. 이것은 디자인 자체는
     보호되지 않지만 그것을 만드는 메커니즘은 보호된다는 것을 의미합니다.
   * 폰트 이름은 상표로 등록될 수 있습니다.

   제가 이해하는 영국 법은 다음과 같습니다.

   * 저작권과 다소 유사하고 5년 동안 디자인을 보호하는 "디자인권"이라는
     것이 있습니다. 디자이너는 또한 이 보호를 25년으로 연장하기 위해
     정부에 디자인을 최대 5번까지 등록할 수 있습니다.

   EU 전역:

   * EU 디자인권이 있습니다. 저는 이것들의 구체적인 내용이나
     (위의 영국 디자인권과 같은) 국가별 법률과 어떻게 상호 작용하는지에
     대해 확실하지 않습니다.

   캐나다:

   * 폰트 디자인은 제한된 기간(~15년) 동안 "산업 디자인"으로 등록될 수
     있습니다.

   여기에 대한 추가 또는 수정 사항과 다른 국가의 폰트를 규율하는 법률에
   대한 정보를 환영합니다. 이 문제에 대해 논의하는
   `typophile의 스레드 <http://typophile.com/node/42709>`__가
   있습니다.

   `폰트 임베딩 <http://www.fontembeddng.com/fonts-and-the-law>`__ 웹사이트에
   좋은 요약이 있습니다.

.. _faq.pointsize:

**12포인트 폰트란 무엇인가요?** **(폰트의 어떤 측정값이 포인트 크기를 결정하나요?)**
   .. image:: /images/pointsize.png
      :align: right

   (리딩이 없는) 텍스트의 인접한 두 줄의 기준선 사이의 거리가 12포인트이면
   폰트는 12포인트 높이입니다.

   포인트 크기는 폰트의 어떤 글리프의 크기를 기반으로 하지 않습니다.

   폰트가 금속으로 만들어졌을 때, 폰트의 포인트 크기는 그 폰트에 사용된
   금속 슬러그의 높이였습니다.

   어떤 의미에서 이것은 폰트의 크기를 측정하는 좋은 방법이 아닙니다(어떤
   폰트는 다른 폰트보다 악센트나 어센더 또는 디센더를 위한 공간을 더 많이
   허용할 수 있으므로 실제 글리프의 높이는 더 작아집니다).

   글리프의 x-높이를 기반으로 한 측정 체계도 있습니다.

   영국과 미국에서는 포인트가 전통적으로 피카 포인트(1/72.27인치)를 의미했지만,
   유럽에서는 포인트가 디도 포인트(1/67.54인치)였습니다. 유럽인들은
   약간 더 큰 포인트를 가지고 있지만, 영국과 유럽 폰트의 글리프는 같은
   크기로 보입니다. 영어는 악센트를 사용하지 않지만(매우 드문 경우 제외),
   대부분의 유럽 언어는 악센트를 사용하며, 포인트 크기의 약간의 증가는
   악센트를 위한 더 많은 공간을 허용합니다.

   (물론 지금은 대부분의 유럽인들이 데스크톱 소프트웨어에 의해 피카 포인트를
   사용하도록 강요받고 있을 것이고, 대부분의 컴퓨터 폰트에는 이제 악센트
   부호가 포함되어 있으므로 구별과 그 이유는 사라졌을 수 있습니다.)

.. _faq.linespace:

**폰트의 줄 간격을 어떻게 설정하나요?**
   그것은 생성하는 폰트의 종류, 실행 중인 운영 체제 및 운에 따라 다릅니다.

   * Type1 폰트의 경우 줄 간격을 설정할 방법이 없습니다. 응용 프로그램은
     종종 폰트의 경계 상자에 지정된 값을 가져와 줄 간격을 설정하는 데
     사용합니다. 이것은 그들의 입장에서 정말 나쁜 생각이지만, 일반적인
     관행입니다.
   * True/Open Type 폰트의 경우 대답은 복잡합니다.

     * Mac에서

       줄 간격은 'hhea' 테이블의 어센더 및 디센더 값으로 설정됩니다.
       이 값들은 차례로 폰트의 경계 상자 값으로 설정됩니다. 좋은 선택은
       아닙니다. :ref:`요소->폰트 정보->OS/2->메트릭 <fontinfo.TTF-Metrics>`에서
       이 값들을 제어할 수 있습니다.
     * Windows에서

       줄 간격은 OS/2 테이블에 지정된 Typo Ascent/Typo Descent 값으로
       설정되어야 합니다. 그리고 이 값들은 차례로 emsize에 합산되어야 합니다.
       (FontForge는 이 값들을 폰트에 대해 지정한 어센트/디센트 값으로 설정합니다.)
       불행히도 대부분의 Windows 응용 프로그램은 이 규칙을 따르지 않고
       대신 OS/2 테이블의 Win Ascent/Descent 값을 기반으로 줄 간격을 설정합니다.
       이 값들은 폰트의 클리핑 영역을 지정해야 합니다(줄 간격이 아님).
       클리핑 영역은 폰트의 경계 상만큼 커야 하지만, 어떤 경우에는 더 커야
       합니다. 다시 이 값들은 :ref:`요소->폰트 정보->OS/2->메트릭 <fontinfo.TTF-Metrics>`에서
       설정할 수 있습니다.

       (GPOS 조회가 글리프를 경계 상자를 넘어 확장하도록 이동시킬 수 있는 경우
       클리핑 영역은 경계 상자보다 커야 합니다(마크 투 베이스가 문제를
       일으킬 가능성이 높습니다). GPOS 조회가 줄을 임의로 높게 만들 수 있는
       우르두어의 필기체 위치 지정에 이것이 어떻게 적용되는지 확실하지 않습니다.)

       MicroSoft는 OS/2 테이블에 중복 비트를 추가했는데, 이는 기본적으로
       응용 프로그램에 표준을 따르고 타이포그래피 줄 간격 필드를 사용해야
       한다고 알려줍니다. 이 비트는 OpenType에서 UseTypoMetrics라고 하며,
       FontForge에서는 :menuselection:`요소 --> 폰트 정보 --> OS/2 --> 메트릭 -->
       실제로 타이포그래피 메트릭 사용`으로 사용할 수 있습니다.
     * Linux에서

       일반적인 합의가 있는지 모르겠습니다. 응용 프로그램은 아마도
       위의 방법 중 하나를 사용할 것입니다.

   실제로 이것은 더 이상 매우 유용한 질문이 아닙니다. 현대 폰트는
   여러 다른 스크립트를 포함하는 경향이 있으며 다른 스크립트는 다른
   줄 간격 요구 사항을 가질 수 있습니다. 한 스크립트 내에서도 차이가 있을
   수 있습니다(영어는 악센트 부호가 있는 문자를 사용하지 않거나 극히 드물게
   사용하는 반면, 대부분의 다른 유럽 언어는 악센트를 사용하므로 영어를
   독일어보다 더 촘촘하게 설정할 수 있습니다).

   폰트의 모든 사용에 대한 줄 간격을 제어하는 하나의 전역 측정값을 갖는
   대신, 조건에 따라 줄 간격을 제어하는 더 구체적인 측정값을 갖는 것이
   더 좋습니다. OpenType :doc:`'BASE' 테이블 </ui/dialogs/baseline>`이 이 작업을
   수행합니다. 스크립트, 언어 및 활성 기능에 따라 범위 데이터를 지정할 수
   있습니다(예: 'mkmk' 기능은 줄 간격을 늘릴 수 있습니다). 어떤 응용 프로그램이
   실제로 이러한 데이터를 사용하는지는 모릅니다.

.. _faq.em-units:

**내 글리프는 얼마나 커질까요?**
   불행히도 이 간단해 보이는 질문에 답할 수 없습니다. 글리프는 어떤 크기든
   될 수 있습니다. 아웃라인 글리프는 크기를 조절할 수 있으며 비트맵 글리프조차도
   화면 해상도에 따라 크기가 다릅니다.

   대신 12포인트로 그리는 아웃라인 폰트가 있다고 가정해 봅시다. 그러면
   질문에 답할 수 있습니다.

   길이가 500 내부 단위인 대시 글리프가 있고 폰트의 em 크기가 1000 단위라고
   가정해 봅시다. 그러면 글리프는 500/1000 * 12 = 6포인트 길이가 됩니다.
   72dpi 화면에서는 대시가 6픽셀 길이가 됩니다.

   **em 단위란 무엇인가요? (내부 단위?)**
      폰트를 만들 때 :ref:`요소->폰트 정보->일반 <fontinfo.PS-General>`을
      사용하여 폰트의 em 크기를 제공할 수 있습니다. 이것은 타이포그래피
      어센트와 디센트의 합입니다(금속 폰트 시대에는 금속 슬러그의 높이,
      기준선에서 기준선까지의 거리). 일반적으로 em 크기는 1000 또는 2048입니다.
      이것은 em을 나타내는 데 사용되는 내부 단위(em 단위라고도 함)의 수를
      제공합니다.

      fontforge 내에서 아웃라인 글리프는 여기에 설정된 좌표계를 사용하여
      표시됩니다. 개요의 :ref:`em 단위에 대한 섹션 <overview.em-unit>`도
      참조하십시오.

.. _faq.license:

**오픈 소스 폰트에 사용하기 좋은 라이선스는 무엇인가요?**
   많은 폰트가 오픈 소스 프로그램을 위해 설계된 라이선스 중 하나로
   출시되었습니다 -- `오픈 소스 이니셔티브 승인 라이선스 목록 <http://www.opensource.org/licenses>`__을
   참조하십시오 -- 하지만 이것들은 일반적으로 폰트 디자이너의 특정 요구를
   충족시키지 못합니다. 저는 폰트를 위해 특별히 제작된 두 가지 라이선스를
   알고 있습니다.

   * `SIL의 오픈 폰트 라이선스 <http://scripts.sil.org/OFL>`__ (및
     `FAQ <http://scripts.sil.org/OFL-FAQ_web>`__)

     위의 것이 제가 추천하는 라이선스입니다. :doc:`OFL의 비공식 번역 모음 </appendices/OFL-Unofficial>`.
     이것들은 법적 구속력은 없지만 비영어권 사용자가 라이선스의 의도를
     이해하는 데 도움이 될 수 있습니다.
   * `Vera 폰트를 출시하는 데 사용된 Bitstream 라이선스 <http://www.gnome.org/fonts/#Final_Bitstream_Vera_fonts>`__

   `GNU 일반 공중 사용 허가서 <http://www.gnu.org/licenses/gpl.html>`__도
   자주 사용됩니다.

.. _faq.Minimum:

**최소 요구 사항**
   이것은 당신이 무엇을 하고 싶은지에 따라 크게 달라집니다. FontForge는 주로
   메모리에 의해 제한됩니다(화면 공간도 문제가 될 수 있습니다).

   * 수백 개의 간단한 글리프(라틴 알파벳과 같은)가 있는 스크립트에 관심이
     있다면 192Mb면 충분합니다.
   * CJK 폰트를 심각하게 편집하는 경우 512Mb는 사용 가능성의 낮은
     쪽입니다.

   FontForge는 컬러(또는 회색조) 모니터가 필요합니다 -- 흑백으로는
   충분하지 않습니다.

   Windows에서 FontForge는 msys2/mingw-w64로 빌드됩니다. 따라서 지원되는
   최소 Windows 버전은 FontForge의 종속 라이브러리가 지원하는 것에
   따라 다릅니다. 이 글을 쓰는 시점에서 이것은 Windows 7 이상입니다.

   Mac에서 번들은 Homebrew로 빌드되며, 마지막 세 가지 버전을 지원합니다.
   이것은 번들도 이 지원 체계에 묶여 있다는 것을 의미하므로, 이 글을
   쓰는 시점에서 지원되는 최소 버전은 macOS 10.13(High Sierra)입니다.

.. _faq.excessive-memory:

**왜 FontForge는 메모리를 많이 사용하나요?**
   폰트는 일반적으로 매우 압축된 표현으로 저장됩니다. 폰트 형식은
   작고 쉽게 래스터화되도록 설계되었습니다. 편집용으로 설계되지 않았습니다.

   폰트를 로드할 때 FontForge는 더 직관적인(저에게는 직관적인) 형식으로
   확장하여 편집하기 훨씬 쉽습니다. 하지만 훨씬 더 큽니다.

   더 효율적인 메모리 표현을 사용하도록 FontForge를 다시 작성하는 것은
   아마도 가능할 것입니다. 하지만 이것은 엄청난 양의 작업이며 저에게는
   흥미롭지 않습니다.

   Sfd 파일은 이 동일한 확장 형식의 ASCII 표현이기 때문에 큽니다.
   압축되도록 설계된 것이 아니라 읽기 쉽도록 설계되었습니다.

   참조:
   :ref:`FontForge가 메모리 부족으로 계속 충돌합니다. 어떻게 해야 하나요? <faq.memory>`

.. _faq.font-install:

**만든 폰트를 어떻게 설치하나요?**
   음, 그것은 당신이 작업하는 시스템과 어떤 종류의 폰트를 가지고 있는지에
   따라 다릅니다.

   .. _faq.X-Install:

   **유닉스 & X**
      아웃라인 폰트 및 fontconfig
         이제 많은 프로그램이 폰트를 찾기 위해 fontconfig를 사용합니다(fontforge 포함).
         fontconfig용 폰트를 설치하려면 파일을 ~/.fonts 디렉터리에 복사하기만 하면 됩니다.

      비트맵 폰트 및 바닐라 X11 설치
         `리눅스 폰트 HOWTO 파일 <http://www.linuxdoc.org/HOWTO/Font-HOWTO.html>`__과
         `폰트 미화 HOWTO <http://www.linuxdoc.org/HOWTO/mini/FDU/>`__를
         좋은 시작점으로 살펴보는 것이 좋습니다. 하지만 하이라이트를 살펴보겠습니다.

         기본적으로 하나(또는 여러 개)의 디렉터리를 "폰트 디렉터리"로 지정합니다.
         폰트를 해당 디렉터리로 이동합니다. X에 필요한 특정 데이터 구조를
         구축하고 X에 이 디렉터리를 폰트 경로에 포함하도록 지시합니다.
         슬프게도 X와 X 폰트 서버의 다른 버전은 약간 다른 규칙을 사용합니다.
         이 절차를 약간 변경해야 할 수도 있습니다.

         예를 들어, frabnuts-13.bdf라는 *bdf 폰트*를 설치하려면 다음을
         수행할 수 있습니다.

         ::

            $ mkdir my_fonts
            $ mv frabnuts-13.bdf my_fonts
            $ cd my_fonts
            $ bdftopcf frabnuts-13.bdf >frabnuts-13.pcf
            $ mkfontdir
            $ xset fp+ `pwd`

         그러면 폰트가 설치됩니다. 그 후 X를 시작할 때마다 폰트가 어디에
         있는지 상기시켜야 하므로 .xsession(또는 동등한 파일)에 다음을
         추가해야 합니다.

            $ xset fp+ /home/me/my_fonts

         *포스트스크립트 폰트*를 설치하려면

         포스트스크립트 바이너리(.pfb) 파일로 생성한 다음 .pfb와 .afm 파일을
         (폰트 디렉터리 중 하나)에 모두 이동하고
         `type1inst <http://rpmfind.net/linux/rpm2html/search.php?query=type1inst>`__를
         실행해야 합니다.

         type1inst는 아마도 당신의 폰트에 파운드리가 없다고 불평할 것이고
         아마도 인코딩을 잘못 가져올 것입니다. 당신은 다음 중 하나를 할 수 있습니다.

         * 무시하면 나쁜 일이 일어나지 않습니다.
         * type1inst를 실행한 후 fonts.scale을 수동으로 편집하여 이러한 항목을
           수정합니다.
         * 폰트의 저작권을 합리적으로 만들고 type1inst를 편집하고 파운드리를
           추가합니다(이에 대한 지침은 type1inst 자체에 있습니다).

         *트루타입 폰트*를 설치하려면

         .ttf 파일을 폰트 디렉터리로 이동하고 mkttfdir과 mkfontdir을 실행합니다.

         (`mkttfdir <http://rpmfind.net/linux/rpm2html/search.php?query=mkttfdir>`__는
         FontForge에서 만든 폰트에 약간의 문제가 있습니다. 거의 항상
         파운드리를 인식하지 못한다고 불평합니다. 이것을 안전하게 무시할 수
         있지만, 신경 쓰인다면 ttmkfdir.c의 936줄에 다음 줄을 추가하십시오.

            { "PFED", "FontForge" },

         일부 X 버전(예: redhat에서 제공하는 버전)은 X 서버 자체 대신 x 폰트
         서버에 의존하여 폰트 작업을 수행합니다. 새 디렉터리를 폰트 서버의
         폰트 경로에 추가하려면 chkfontpath를 사용해야 할 수도 있습니다(xset fp
         대신).

         또한 폰트 디렉터리(및 모든 상위 디렉터리)가 world에서 읽을 수
         있는지 확인해야 할 수도 있습니다. (폰트 서버는 권한 없는 사용자로
         실행됩니다.)

         X가 *오픈타입* 폰트를 지원한다는 것을 본 적이 없지만, freetype이
         지원하므로(그리고 X의 래스터라이저가 freetype을 사용하는 것 같습니다)
         X도 지원할 수 있습니다. 그것들을 설치하려면 fonts.scale을 수동으로
         편집해야 합니다(mkttfdir은 otf 파일을 지원하지 않는 freetype1을
         사용합니다).

         정말 혼란스럽게 들립니다. 죄송합니다. 저는 글을 잘 쓰지 못하고
         X를 구성하는 데 너무 많은 선택지가 있습니다...

      **KDE**
         (저는 KDE를 잘 모르므로 제 경험은 참고로만 하십시오) KDE에는
         `kfontinst <http://www.cpdrummond.uklinux.net/kfontinst/>`__라는 도구가
         있어 모든 구성 작업을 대신해 준다고 합니다. 저는 루트로만 작동시킬 수
         있었고 제 시스템을 그 규칙에 따르도록 다시 구성해야 했지만, 일단
         그렇게 하고 나니 X 폰트를 아주 쉽게 설치했습니다. ghostview 폰트를
         설치하는 방법을 알아내지 못했습니다. (버전 0.9.2로 실험했습니다.)

   **TeX**
      TeX는 폰트 설치를 위한 자체적인 (플랫폼 독립적인) 시스템을 가지고 있습니다.
      저는 지금까지의 경험을 :ref:`이 문서의 다른 곳 <PfaEdit-TeX.TeX-Install>`에
      설명했습니다.

   .. _faq.Windows-Install:

   **Windows**
      Windows에 truetype 폰트를 설치하려면 컴퓨터의 \\Windows\\Fonts
      디렉터리에 끌어다 놓습니다. 설치하기 전에 폰트에 실행 권한 비트를
      설정해야 할 수도 있습니다.

      .. warning::

         **절대** \\Windows\\Fonts에 직접 폰트를 생성하지 마십시오.
         이것은 작동하지 않는 것 같습니다(적어도 제 XP 컴퓨터에서는). 폰트를
         다른 디렉터리에 생성한 다음 \\Windows\\Fonts로 끌어다 놓아야 합니다.

      type1 폰트를 사용하려면 adobe type manager를 설치하고 그 지침을
      따라야 합니다.

      opentype 폰트를 설치하려면 이전 시스템(windows 2000 이전이라고 생각합니다)에서는
      ATM을 설치해야 하고, 최신 시스템에서는 opentype이 truetype과 동일한
      방식으로 작동해야 합니다.

   .. _faq.OS9-Install:

   **매킨토시 OS 9**
      오, 이런. Mac은 폰트를 리소스 포크에 넣고 자체 헤더로 감쌉니다.
      Mac 폰트는 다른 누구의 것과도 호환되지 않습니다. FontForge는 폰트를
      macbinary 인코딩으로 감싸면 리소스 포크를 만들 수 있습니다. 자세한
      내용은 :ref:`다음 질문 <faq.How-mac>`을 참조하십시오.

      저는 또한 `한 형식에서 다른 형식으로 변환하도록 설계된 몇 가지 유틸리티
      <http://fondu.sourceforge.net/>`__를 작성했으며 유용할 수 있습니다.

      `오레곤 대학교에는 도움이 될 수 있는 몇 가지 링크가 있습니다
      <http://babel.uoregon.edu/yamada/fontconversionfaq.html>`__.

      폰트를 변환한 후에는 시스템 폴더에 끌어다 놓기만 하면 그 후에는
      사용할 수 있습니다.

   .. _faq.OSX-Install:

   **매킨토시 OS X**
      OS/X에서는 폰트를 최상위 라이브러리/폰트 디렉터리(기본적으로 ``/Mac
      OS X/Library/Fonts/``), 시스템/라이브러리/폰트 디렉터리 또는 사용자의
      적절한 폰트 하위 디렉터리(``~/Library/Fonts``)에 배치해야 합니다.

      리소스 폰트(macbinary 래퍼에서 풀림) 또는 dfont를 사용할 수 있습니다.
      일반적인 ttf 및 otf 파일(즉, Unix 또는 MS에서 사용할 수 있는 동일한
      파일)도 사용할 수 있습니다.

      제가 아는 한, 이전 NFNT 비트맵 리소스는 제 OS 10.2에서 작동하지 않습니다.
      비트맵 폰트를 사용하려면 ttf 파일이나 sfnt에 래핑하십시오. 그러나
      Type1 리소스 폰트를 사용하려면 (쓸모없는) 비트맵 폰트를 생성하고
      둘 다 설치해야 합니다.

.. _faq.Bad-Windows-Install:

**왜 FontForge 폰트가 일부 MS Windows 컴퓨터에 설치되지 않나요?**
   **절대** \\windows\\fonts 디렉터리에 직접 폰트를 생성하지 마십시오.
   폰트를 다른 디렉터리에 생성한 다음 Windows 끌어서 놓기를 사용하여
   폰트를 설치하십시오. (Windows는 폰트를 해당 디렉터리로 이동할 때
   마법을 부리는 것 같습니다.)

   최근(2009년) Windows 보안 패치에서 'name' 테이블이 5K보다 큰 폰트는
   안전하지 않다고 판단하고 설치를 거부했습니다. 종종 이것은 폰트에
   라이선스의 전체 텍스트가 포함되어 있기 때문에 발생합니다.

   FontForge의 이전 버전으로 만든 폰트는 Windows 2000(및 XP) 시스템에
   설치되지 않는다고 들었습니다.

   저는 이 문제가 지금(2003년 10월 20일 기준) 해결되었다고 생각합니다.
   이전 버전이 있다면 업그레이드하십시오.

   다른 컴퓨터에서 폰트를 복사하는 경우 폰트 파일의 권한에 실행 비트가
   설정되어 있는지 확인하십시오(Windows UI에서 이 작업을 수행하는 방법을
   모릅니다. cygwin에서는 ``$ chmod +x foo.ttf``라고 말합니다).

.. _faq.How-mac:

**Mac에서 폰트를 어떻게 편집하나요?**
   Mac OS/9 (이하)
      전통적으로 매킨토시는 파일의 리소스 포크에 폰트를 저장했습니다
      (OS/8.5 이후에는 Mac도 bare .ttf 파일을 지원했다고 생각합니다).
      이것은 리소스 포크라는 개념 자체가 없기 때문에 Mac 이외의 모든
      컴퓨터에 문제를 일으킵니다.

      Macintosh 파일의 모든 것을 다른 시스템에서 조작할 수 있는 하나의
      패키지에 저장하는 여러 프로그램이 있습니다(mac binary와 binhex가
      가장 일반적입니다). FontForge는 이 두 형식을 모두 읽는 방법을 알고
      있으며 어느 쪽에서든 포스트스크립트 또는 트루타입 폰트를 추출할 수
      있습니다. FontForge는 또한 macbinary 형식으로 폰트를 만들 수
      있습니다(두 출력 형식을 모두 지원할 이유가 없다고 생각하며,
      macbinary가 약간 더 간단합니다).

      따라서 Mac에서 폰트를 편집하려면:

      #. ``시스템 폴더:폰트`` 폴더에서 파일을 찾으십시오.
      #. 파일을 유닉스 컴퓨터로 복사하십시오.

         * Fetch를 사용하고 macbinary 형식을 지정하십시오.
         * 또는 파일을 직접 만들 수 있는 binhex와 같은 도구를 사용하십시오.
      #. FontForge에서 엽니다.
      #. 편집합니다.
      #. macbinary 형식으로 다시 저장합니다.
      #. Mac으로 다시 복사합니다.

         * Fetch는 macbinary 래퍼를 자동으로 풀고 올바르게 만듭니다.
         * 또는 다른 다양한 도구로 풀 수 있습니다.
      #. 시스템 폴더에 다시 놓습니다(자동으로 폰트로 이동됨).

      **참고:** 원본 폰트 파일을 교체하거나 fontforge 내에서 폰트
      이름을 바꾸고 (포스트스크립트 폰트의 경우) 새 고유 ID를 부여해야
      합니다. :doc:`폰트 정보 </ui/dialogs/fontinfo>` 대화 상자를 참조하십시오.

      **주의:** 포스트스크립트 폰트는 적어도 하나의 비트맵 폰트와 함께
      제공되지 않으면 매킨토시에서 쓸모가 없습니다. 포스트스크립트 폰트를
      생성하는 경우 NFNT도 생성해야 합니다(FOND가 있습니다).

      **주의:** Mac은 포스트스크립트 파일을 포함하는 데 사용되는 파일
      이름에 대해 까다롭습니다. 포스트스크립트 폰트 이름을 기반으로 하지만
      변환을 겪습니다. 이 파일의 이름을 바꾸려고 하지 마십시오. 기본적으로
      규칙은 다음과 같습니다(`Adobe 기술 노트 0091 <http://partners.adobe.com/asn/developer/pdfs/tn/0091.Mac_Fond.pdf>`__ 참조).

      * 폰트 이름은 각 청크가 대문자로 시작하는 청크로 나뉩니다.
      * 첫 번째 청크는 초기 대문자 뒤에 4개의 소문자를 가질 수 있습니다.
      * 후속 청크는 대문자 뒤에 2개의 소문자만 가질 수 있습니다.
      * 문자가 아닌 글리프(또는 적어도 하이픈)는 사라집니다.

        따라서 TimesBold => TimesBol, Helvetica-BoldItalic => HelveBolIta,
        NCenturySchoolbook => NCenSch

   Mac OS/X
      Mac OS/X에서는 FontForge를 직접 실행할 수 있습니다. OS/X에는 여러
      폰트 형식이 있으며, 일부 폰트는 이전 형식으로 저장되고(위 참조),
      다른 폰트는 데이터 포크 리소스로 저장됩니다. 데이터 포크 폰트
      파일은 일반적으로 ".dfont" 확장자를 가집니다. Mac에서 FontForge는
      두 형식을 모두 직접 편집할 수 있습니다. OS/X는 또한 일반적인 .otf
      및 .ttf 폰트 파일도 지원합니다.

      Mac OS/X는 이전 NFNT 비트맵 형식을 지원하지 않는 것 같지만,
      리소스 기반 포스트스크립트 폰트를 사용하기 전에 NFNT 형식의
      비트맵 폰트가 있어야 합니다. (필요한 것은 NFNT 리소스가 아니라
      그와 함께 제공되는 FOND일 것입니다. 하지만 저는 베어 FOND 리소스를
      생성하는 것을 작성하지 않을 것입니다 -- 다른 누구도 그렇게 하지 않습니다.)

.. _faq.How-family:

**Mac 폰트 패밀리를 어떻게 만드나요? (Mac에서 이탤릭 및 볼드 스타일이 작동하도록 폰트를 그룹화하려면 어떻게 해야 하나요?)**
   10.6에서는 폰트를 그룹화하는 선호하는 방법이 ttc 파일을 사용하는 것이라고
   들었습니다. 10.6 이전에는 ttc 파일이 잘 작동하지 않았고(잘) 선호하는
   방법은 Mac 폰트 패밀리를 만드는 것이었습니다.

   Snow Leopard (10.6) 이상
      먼저 fontforge에서 패밀리를 구성하는 모든 폰트를 엽니다.

      그런 다음 :menuselection:`파일 --> TTC 생성`을 선택합니다.

      이것은 이전 방법보다 더 간단해야 합니다.

   Leopard (10.5) 이하
      대부분의 Mac 응용 프로그램의 스타일 메뉴가 폰트에서 작동하려면
      폰트 패밀리를 만들어야 합니다. 이것은 :ref:`파일->Mac 패밀리 생성
      <filemenu.GenerateMac>` 명령으로 수행합니다.

      패밀리의 모든 폰트는 동일한 패밀리 이름을 가져야 합니다(:doc:`폰트 정보
      </ui/dialogs/fontinfo>` 대화 상자 참조). 폰트 패밀리는 Carbon(OS 9에서
      사용된 이전 폰트 처리 메커니즘)과 ATSUI(OS/X에서)에서 상당히 다르게
      처리됩니다.

      Carbon에서 폰트 패밀리는 1980년대 초반의 컴퓨터 폰트 기술을
      반영하는 Mac 'FOND' 리소스의 디자인에 의해 제한됩니다. 현대 컴퓨터
      폰트는 종종 그 안에 표현할 수 없는 변형을 가지고 있습니다. FOND는
      다음 스타일의 모든 조합을 지원합니다(Extend와 Condense를 모두
      포함하는 조합 제외).

      * 볼드
      * 이탤릭
      * 축소
      * 확장
      * 밑줄
      * 그림자
      * 외곽선

      Mac FOND는 "Black", "DemiBold", "Light", "Thin" 또는 "Extra-Condensed"
      변형을 지원하지 않습니다.

      반면에 ATSUI에서는 패밀리가 동일한 FamilyName을 가진 특정 리소스
      파일의 모든 폰트로 구성되는 것 같습니다.

      두 시스템에서 모두 유용한 패밀리가 되도록 Apple은 이러한 폰트 파일
      안에 여러 FOND를 배치하는 것 같습니다. 각 FOND에는 관련 폰트의
      하위 패밀리가 포함되어 있습니다. 'FOND'는 다음과 같이 배포되는 것
      같습니다.

      다음과 같은 스타일의 폰트 패밀리가 있다고 가정해 봅시다.

      레귤러, 볼드, 이탤릭, 볼드-이탤릭, 축소, 축소-이탤릭, 사체, 라이트,
      라이트-이탤릭, 블랙

      그러면 FOND가 지원하는 스타일로 폰트 패밀리를 만들어야 합니다.
      이 경우에는 다음과 같습니다.

      레귤러, 볼드, 이탤릭, 볼드-이탤릭, 축소, 축소-이탤릭

      각각에 대해 :ref:`요소->폰트 정보->Mac <fontinfo.FONDName>`을 사용하여
      FondName 필드를 폰트의 패밀리 이름으로 설정합니다.

      다른 스타일의 fondname을 변경하여 사체 스타일에는 사체가, 두 라이트
      스타일에는 라이트가, 이런 식으로 fond 이름에 포함되도록 합니다.
      폰트의 "라이트" 변형의 :ref:`Mac 스타일 <fontinfo.Mac-Style>`을 레귤러로
      설정하고(모두 선택 해제) "라이트-이탤릭" 변형의 스타일을 "이탤릭"으로
      설정합니다 -- 즉, "라이트"는 잊어버리십시오. FOND는 그것을 처리할 수
      없으므로 자체 FOND로 옮겼습니다.

      이렇게 설정하면 :ref:`Mac 패밀리 생성 <filemenu.GenerateMac>` 명령이
      모든 폰트를 적절한 FOND에 넣고 모든 FOND를 하나의 파일에 넣을 수
      있어야 하며, Mac은 이를 올바르게 해석해야 합니다.

.. _faq.Mac-ATM:

**왜 ATM이 제 (Mac) 폰트에서 작동하지 않나요?**
   폰트를 생성할 때 폰트에 Macintosh Latin 인코딩이 있는지 확인하십시오.

   이것은 실제로 ATM의 한계이며 FontForge가 할 수 있는 일은 없습니다.

   Macintosh Latin 이외의 인코딩으로 폰트를 생성하면 Mac의 기본 동작은
   포스트스크립트 폰트에 Macintosh Latin 인코딩을 강제로 적용하는 것입니다.
   이 동작을 끄는 메커니즘이 있지만, 꺼지면 ATM이 전혀 작동하지 않습니다.

.. _faq.windows:

**MS Windows에서 폰트를 어떻게 편집하나요?**
   `MS Windows 설치 지침 <https://fontforge.org/en-US/downloads/windows-dl/>`__을
   참조하십시오.

.. _faq.Bad-Windows-Fonts:

**왜 제 폰트가 Windows에서 작동하지 않나요?**
   한 가지 가능성이 있습니다. Windows는 때때로(언제인지는 모릅니다)
   적절한 언어로 된 폰트 이름이 필요하다고 주장합니다(예: SJIS 폰트의
   일본어 항목). :ref:`요소->폰트 정보->TTF 이름 <fontinfo.TTF-Names>`으로
   이동하여 해당 언어에 대한 문자열 세트를 추가해 보십시오.

   또 다른 가능성은 :ref:`여기 <faq.Bad-Windows-Install>`에서 논의됩니다.

.. _faq.Missing-Refs:

**otf 또는 type1 폰트를 로드하면 대부분의 참조가 인라인 복사본으로 대체되었습니다. 참조를 다시 가져오려면 어떻게 해야 하나요?**
   포스트스크립트 폰트를 로드할 때 이전 참조를 알아내는 것은 매우 어렵습니다.
   대신 FontForge에는 :ref:`편집->참조로 바꾸기 <editmenu.ReplaceRef>`라는
   특수 명령이 있어 폰트에서 잠재적인 참조 후보를 검색하고 참조로 바꿉니다.

.. _faq.kern-info:

**FontForge는 폰트에서 이전 커닝 정보를 읽어오나요?**
   이 질문은 경우에 따라 나누어야 합니다.

   **TrueType 및 OpenType 폰트**
      예. 커닝 정보는 이러한 폰트의 'kern' 또는 'GPOS' 테이블에 저장되며
      FontForge는 이를 읽을 수 있습니다(Apple은 원래 truetype 사양을 넘어
      많은 확장을 했으며 FontForge도 이를 읽을 수 있습니다).

   **Mac 이외의 모든 곳에서 PostScript Type1 폰트.**
      커닝 정보는 Type 1 폰트 파일에 저장되지 않습니다. 대신 폰트 파일과
      동일한 파일 이름을 가지지만 확장자가 ".afm"인 파일에 저장됩니다.
      FontForge가 PostScript 폰트를 읽을 때 관련 afm 파일을 확인하고,
      발견되면 거기에서 커닝 정보를 읽습니다.

   **Mac에서 PostScript Type1 폰트.**
      아니요. 다시 말하지만 커닝 정보는 폰트 파일에 저장되지 않습니다(비트맵
      폰트 파일에 저장됨). 하지만 Mac에서는 관련 비트맵 파일에 사용할 이름을
      추측하는 것이 불가능하며 FontForge는 시도조차 하지 않습니다.

      :ref:`FOND <faq.FOND-kern>`에서 커닝을 로드하는 방법에 대한 아래 정보를
      참조하십시오.

   **AFM 및 TFM 파일.**
      FontForge는 이러한 파일에서 직접 커닝 정보를 읽고 해당 데이터를
      폰트에 적용할 수 있습니다. :ref:`파일->기능 정보 병합
      <filemenu.Merge-feature>` 메뉴 명령을 참조하십시오.

   .. _faq.FOND-kern:

   **FOND 리소스를 포함하는 Mac 리소스 파일.**
      Mac은 비트맵 폰트와 관련된 FOND 리소스에 커닝 정보를 저장했습니다(포스트스크립트
      폰트가 있는 파일에 저장되지 않음). Mac 포스트스크립트 폰트에 대한
      커닝 데이터가 필요한 경우 포스트스크립트와 동일한 패밀리 및 스타일을
      가진 비트맵 폰트가 있는 폰트 파일을 찾아야 합니다. FontForge는 이러한
      파일에서 직접 커닝 정보를 읽고 해당 데이터를 폰트에 적용할 수 있습니다.
      :ref:`파일->기능 정보 병합 <filemenu.Merge-feature>` 메뉴 명령을
      참조하십시오.

   **Adobe 기능 파일**
      Adobe는 OpenType 기능 및 조회를 위한 텍스트 표현을 가지고 있으며,
      fontforge는 :ref:`파일->기능 정보 병합 <filemenu.Merge-feature>` 메뉴
      명령으로 이러한 파일을 읽을 수 있습니다.

.. _faq.outline-conversion:

**한 아웃라인 형식에서 다른 형식으로 어떻게 변환하나요?**
   빠른 것을 원한다면 작동할 간단한 대답은 다음과 같습니다.

   #. 파일->열기

      * 기존 폰트
   #. :doc:`요소->폰트 생성 </ui/dialogs/generate>`

      * 원하는 출력을 생성합니다.

   한 PostScript 형식에서 다른 형식으로(예: pfb에서 otf로) 변환하는 경우
   이것이 전부입니다. PostScript와 TrueType 간에 변환하는 경우 조금 더
   작업하면 문제를 개선할 수 있습니다.

   TrueType(2차 스플라인, ttf 파일)에서 PostScript(3차 스플라인, otf 및
   pfb 파일)로 변환:

   #. 파일->열기

      * (트루타입 폰트)
   #. :ref:`요소->폰트 정보->레이어 <fontinfo.Layers>`

      * <*> 모든 레이어 3차 확인
      * [확인]
   #. :menuselection:`편집 --> 선택 --> 모두 선택`
   #. :ref:`요소->단순화->단순화 <elementmenu.Simplify>`
   #. :ref:`힌트->자동 힌트 <hintsmenu.AutoHint>`
   #. :doc:`요소->폰트 생성 </ui/dialogs/generate>`

   PostScript(3차 스플라인, otf 및 pfb 파일)에서 TrueType(2차 스플라인,
   ttf 파일)로 변환:

   #. :menuselection:`파일 --> 열기`
   #. :ref:`요소->폰트 정보->레이어 <fontinfo.Layers>`

      * <*> 모든 레이어 2차 확인
      * [확인]
   #. :menuselection:`편집 --> 선택 --> 모두 선택`
   #. :ref:`힌트->자동 지침 <hintsmenu.AutoInstr>`
   #. :doc:`요소->폰트 생성 </ui/dialogs/generate>`

.. _faq.bitmap-conversion:

**한 비트맵 형식에서 다른 비트맵 형식으로 어떻게 변환하나요?**
   이것 또한 쉽습니다. 비트맵 폰트를 열고 :doc:`요소->폰트 생성
   </ui/dialogs/generate>`을 사용하여 원하는 출력을 생성합니다.

.. _faq.outline-bitmap:

**아웃라인 형식에서 비트맵 형식으로 어떻게 변환하나요?**
   아웃라인 폰트를 로드합니다. 그런 다음 :ref:`요소->사용 가능한 비트맵
   <elementmenu.Bitmaps>`을 사용하여 적절한 크기의 비트맵 스트라이크를
   생성합니다. 이 과정을 래스터화라고 하며, 작은 픽셀 크기에서는 컴퓨터가
   잘 수행하기 어렵습니다. :doc:`비트맵 창 </ui/mainviews/bitmapview>`에서
   래스터화 결과를 검토하고( :ref:`창->비트맵 창 열기 <windowmenu.Bitmap>`
   사용), 진행하면서 비트맵을 수정하는 것이 좋습니다. 그런 다음 완료되면
   :doc:`요소->폰트 생성 </ui/dialogs/generate>`을 선택하고, 아웃라인 폰트
   생성을 끄고(물론 아웃라인 폰트도 원하는 경우 제외), 원하는 비트맵
   형식을 선택합니다.

.. _faq.bitmap-outline:

**비트맵 형식에서 아웃라인 형식으로 어떻게 변환하나요?**
   매우 큰 비트맵 폰트(예: TeX 폰트)가 없는 한 다음 절차는 좋은 결과를
   내지 못할 것입니다.

   * 다른 작업을 하기 전에 시스템에 :doc:`potrace 또는 autotrace 프로그램
     </techref/autotrace>`이 설치되어 있는지 확인하십시오.

--------------------------------------------------------------------------------

   * 새 폰트 만들기
   * :ref:`파일->가져오기 <filemenu.Import>` 명령을 사용하여 비트맵 폰트를
     이 새 폰트로 가져옵니다.

     * ``[] 배경으로`` 확인란을 선택해야 합니다.
   * :menuselection:`편집 --> 선택 --> 모두 선택`
   * :menuselection:`요소 --> 자동 추적`
   * :menuselection:`요소 --> 극값 추가`
   * :menuselection:`요소 --> 단순화`

     이 시점에서 아웃라인 글리프를 보고 정리하고 싶을 것입니다.
   * :menuselection:`파일 --> 폰트 생성`

.. _faq.AAT2OT:

**Apple의 고급 타이포그래피에서 OpenType으로 변환하기**
   이러한 형식으로 얻은 결과 사이에는 여러 가지 유사점이 있지만
   겹침은 완전하지 않습니다. 대부분의 변환은 일부 정보를 잃게 됩니다.

   간단한 대답은 이것이 거의 자동이라는 것입니다. Apple 폰트를 로드한 다음
   옵션 대화 상자에서 [*] OpenType 확인란을 선택하여 동등한 폰트를
   생성합니다.

   FontForge는 Apple의 기능/설정이 OpenType 기능과 일치하는 모든
   비문맥적 기능을 변환합니다. (이것은 문맥적 형식에 있더라도
   비문맥적 합자를 포함합니다.) 자세한 내용은 이 :ref:`상호 변환
   <gposgsub.Conversion>`에 대한 섹션을 참조하십시오.

.. _faq.OT2AAT:

**OpenType에서 AAT로 변환하기**
   다시 말하지만 이것은 대부분 자동입니다. OpenType 폰트를 로드하고 옵션
   대화 상자에서 [*] Apple 확인란을 선택하여 동등한 폰트를 생성합니다.

   FontForge는 일부 문맥적 OpenType 테이블을 AAT로 변환할 수 있습니다.
   Apple 기능/설정과 일치하는 비문맥적 기능도 변환됩니다. 자세한 내용은
   이 :ref:`상호 변환 <gposgsub.Conversion>`에 대한 섹션을 참조하십시오.

.. _faq.hint-subs:

**FontForge가 힌트 대체를 사용하도록 하려면 어떻게 해야 하나요?**
   자동으로 발생합니다.

   또는 점을 선택하고 :ref:`요소->정보 가져오기 <getinfo.HintMask>`\
   ->힌트 마스크를 선택하여 힌트 세트가 변경되는 위치를 제어할 수 있습니다.

.. _faq.flex-hints:

**FontForge가 flex 힌트를 사용하도록 하려면 어떻게 해야 하나요?**
   자동으로 발생합니다. FontForge는 적절한 상황에서 flex 힌트를 생성합니다.
   아무것도 할 필요가 없습니다. flex 힌트가 사용되면 필요한 서브루틴이
   폰트에 추가됩니다. 필요하지 않으면 서브루틴이 추가되지 않습니다.

.. _faq.flex2:

**FontForge가 flex 힌트를 사용할지 어떻게 알 수 있나요?**
   FontForge가 flex 힌트를 사용할지 확인하려면 :ref:`UpdateFlex
   <prefs.UpdateFlex>` 기본 설정 항목을 켜고 글리프에 대한 뷰를 엽니다.
   FontForge는 flex 힌트의 중심점 주위에 녹색 후광을 표시합니다.

.. _faq.fuzzy:

**제 글리프는 모두 완벽하게 힌트 처리되었는데 왜 일부 스템의 너비가 다르거나(또는 흐릿하게 보이거나 완전히 사라지나요)?**
   PostScript와 TrueType 모두 글리프를 시계 방향으로 그려야 합니다.
   일부 래스터라이저는 신경 쓰지 않습니다. 하지만 다른 래스터라이저는
   시계 반대 방향 경로에 어려움을 겪고 스템이 같아야 할 때 너비가
   다른 스템을 생성하거나, 흐릿한 스템을 생성하거나, 심지어 아무것도
   생성하지 않을 수도 있습니다. 이 문제의 해결책은 폰트를 생성하기 전에
   모든 글리프에 대해 :menuselection:`요소 --> 방향 수정`을 실행하는 것입니다.

   하지만 때로는 가난한 래스터라이저가 올바른 일을 할 수 없을 때도 있습니다...

.. _faq.mensis:

**OS/2 테이블(또는 다른 테이블)의 특정 비트를 어떻게 설정하나요?**
   FontForge는 이 작업을 수행하지 않지만, 저는 `mensis
   <http://mensis.sf.net/>`__라는 동반 프로그램을 작성했습니다(라틴어로:
   "테이블에 대해, 테이블에 의해, 테이블과 함께 또는 테이블로부터").
   이 프로그램은 테이블에 대한 비트 액세스를 제공합니다. UI와 스크립팅
   액세스를 모두 제공합니다.

.. _faq.sfd:

**sfd 파일이란 무엇인가요?**
   이것은 FontForge 자체 형식입니다. 텍스트 파일이므로 크지만 사람이 읽을
   수 있습니다(결심한 사람이면). ASCII 문자만 사용하므로 인터넷으로
   전송할 때 오래된 메일 프로그램에 의해 왜곡되지 않아야 합니다(등록된
   MIME 유형 ``application/vnd.font-fontforge-sfd``입니다).

   :doc:`형식 개요. </techref/sfdformat>`

.. _faq.background:

**FontForge의 회색 배경이 마음에 들지 않습니다. 어떻게 변경하나요?**
   일반적인 메커니즘은 :doc:`X 리소스 페이지 </ui/misc/xres>`에서 논의됩니다.

   :doc:`시도해 볼 수 있는 몇 가지 조합이 있습니다 </ui/misc/fontforge-themes>`.

.. _faq.fontsize:

**FontForge가 GUI에서 사용하는 폰트가 너무 작습니다(너무 큽니다). 어떻게 변경하나요?**
   X 서버는 화면 해상도에 대한 좋은 아이디어가 없으며, fontforge가
   물어보면 대답이 종종 틀립니다. 그 결과 ff는 너무 작은 폰트를 사용할
   수 있습니다(너무 클 수도 있지만 아직 아무도 불평하지 않았습니다).
   다음과 같은 줄을 추가하여 fontforge에 실제 화면 크기를 알려줄 수 있습니다.

   ::

      Gdraw.ScreenWidthInches: 14.7
      Gdraw.ScreenWidthCentimeters: 37.3

   ``~/.Xdefaults`` 파일에 추가합니다(일반적인 메커니즘은 :doc:`X 리소스
   페이지 </ui/misc/xres>`에서 논의됩니다). GUI 폰트가 여전히 너무 작으면
   화면 크기에 대해 거짓말을 할 수 있습니다. 화면이 실제보다 작다고(인치
   또는 센티미터 단위로) 주장하면 ff는 더 큰 폰트를 사용합니다.

.. _faq.monospace:

**폰트를 고정 폭으로 어떻게 표시하나요?**
   표시하지 않습니다. 폰트의 모든 글리프가 동일한 너비를 갖도록 하기만 하면
   FontForge가 자동으로 고정 폭으로 표시합니다. (잘못 표시하면 일부
   래스터라이저가 이상한 결과를 줄 수 있습니다.)

   폰트의 panose 값을 직접 설정하려면(:ref:`요소->폰트 정보->OS/2->Panose
   <fontinfo.Panose>`) Proportion 필드를 Monospaced로 설정하십시오. 이것은
   필요하지만 폰트 전체를 고정 폭으로 표시하는 데는 충분하지 않습니다.

   폰트의 모든 글리프가 동일한 전진 폭을 가지고 있는지 확실하지 않은 경우
   :ref:`요소->문제 찾기->임의->전진 확인 <problems.Advance>`을 사용하십시오.

   "모든 글리프"라고 말할 때 저는 *모든* 글리프를 의미합니다. 유니코드가
   0 너비여야 한다고 말하는 글리프조차도 다른 모든 것과 동일한 너비를
   가져야 합니다. MicroSoft는 GPOS를 사용하여 악센트 조합(등)을 수행한 다음
   모든 표시(악센트)의 전진 폭을 0으로 변경할 것을 제안합니다.

.. _faq.new-encoding:

**fontforge에 새 인코딩을 어떻게 알리나요?**
   먼저 새 인코딩이 정말 필요한지 자문해 보십시오. OpenType 또는 TrueType
   폰트를 사용하는 경우 일반적으로 표준 유니코드 인코딩으로 충분합니다.
   하지만 정말로 새 인코딩이 필요한 경우 수행할 작업에 대한 대략적인
   아이디어는 다음과 같습니다.

   인코딩이 어떻게 생겼는지 파악하십시오. 종종 이것은 해당 인코딩의 예를
   찾기 위해 웹을 검색하는 것을 포함합니다. 예를 들어 데바나가리 인코딩을
   원하는 경우 `ISCII 인코딩을 보여주는 사이트
   <http://www.cwi.nl/~dik/english/codes/indic.html>`__를 볼 수 있습니다.

   이러한 인코딩은 상위 96자만 보여주며, 아마도 다른 것들은 US ASCII와
   동일할 것입니다. 이미지를 보고 유니코드에 어떻게 매핑되는지(또는 더
   정확하게는 해당 문자에 대한 적절한 포스트스크립트 이름이 무엇인지)
   파악하십시오.

   파일을 만듭니다(이 경우 "Devanagari.ps"라고 부름). 다음 줄로 시작해야
   합니다.

   ::

      /Devanagari {

   이것은 FontForge에 인코딩 이름이 "Devanagari"임을 알려주고, 그 뒤에
   모든 문자 이름 목록(슬래시 앞에 있음)이 따릅니다. 32개의 .notdef
   문자로 시작하는 ASCII로 시작한 다음 공백 등입니다.

   ::

      /Devanagari {
       /.notdef
       /.notdef
       ...
       /.notdef
       /space
       /exclam
       /quotedbl
       ...
       /braceright
       /asciitilde
       /.notdef
       ...
       /.notdef
       /uni0901
       /uni0902
       ...
       /uni096F
      }

   이제 이 파일을 인코딩->인코딩 로드를 사용하여 FontForge의 인코딩 목록에
   로드한 다음 원하는 모든 폰트에 적용하십시오.

.. _faq.new-name:

**새 이름으로 글리프를 어떻게 추가하나요?**
   ISO-8859-1 폰트에 "dotlessi" 글리프를 추가하고 싶다고 가정해 봅시다(이
   인코딩에는 dotlessi가 포함되지 않음). 문제에 접근하는 두 가지 방법이
   있습니다.

   #. :menuselection:`인코딩 --> 인코딩 슬롯 추가...`를 엽니다.

      원하는 추가 글리프 수를 입력합니다(아마도 1).

      ``확인``을 누릅니다.

      폰트 끝으로 스크롤하여 새 슬롯을 찾습니다.

      선택합니다.

      :menuselection:`요소 --> 글리프 정보`를 엽니다.

      ``유니코드 이름`` 필드에 새 이름을 입력합니다(이 예에서는
      ``dotlessi``를 입력합니다).

      ``이름에서 설정`` 버튼을 누릅니다.

      ``확인``을 누릅니다.

      이제 글리프에 dotlessi를 그립니다.
   #. :menuselection:`인코딩 --> 다시 인코딩 --> ISO-10646-1`을 엽니다.

      :menuselection:`보기 --> 이동`을 엽니다.

      ``dotlessi``를 입력합니다.

      ``확인``을 누릅니다.

      이제 선택한 글리프 슬롯에 dotlessi 글리프를 그립니다.

      :menuselection:`인코딩 --> 다시 인코딩`을 다시 엽니다.

      인코딩을 원래대로 변경합니다.

.. _faq.glyphnames:

**왜 FontForge가 일부 글리프에 잘못된 이름을 부여하나요?**
   FontForge의 명명 규칙은 `Adobe의 글리프 명명 규칙
   <http://partners.adobe.com/public/developer/opentype/index_glyph.html>`__에
   명시된 것이며, 불행히도 여기에는 몇 가지 문제가 있습니다(일반적으로
   이전 인코딩과의 호환성을 위해). 저는 다음과 같은 문제를 알고 있습니다.

   델타
      U+0394, "GREEK CAPITAL LETTER DELTA"가 아닌 U+2206, "INCREMENT"에
      할당되었으며, 아마도 Increment가 이전 MacRoman 인코딩의 일부였기
      때문일 것입니다.

   오메가
      U+03A9, "GREEK CAPITAL LETTER OMEGA"가 아닌 U+2126, "OHM SIGN"에
      할당되었습니다.

   뮤
      U+03BC, "GREEK SMALL LETTER MU"가 아닌 U+00B5, "MICRO SIGN"에
      할당되었으며, 아마도 Micro Sign이 ISO-Latin1 및 MacRoman의 일부였기
      때문일 것입니다.

   omega1
      유니코드는 이 글리프를 "GREEK PI SYMBOL"이라고 부릅니다. 하지만
      오메가처럼 보입니다.

   Tcommaaccent, tcommaaccent
      U+021A,U+021B "LATIN CAPITAL/SMALL LETTER T WITH COMMA BELOW"가 아닌
      U+0162,U+0163 "LATIN CAPITAL/SMALL LETTER T WITH CEDILLA"에
      할당되었으며, 아마도 초기 유니코드 사양의 혼동 때문일 것입니다.

   dotlessj
      U+0237 "LATIN SMALL LETTER DOTLESS J"가 아닌 U+F6BE(개인 사용 영역)에
      할당되었으며, Adobe가 유니코드보다 먼저 dotlessj 글리프의 필요성을
      보고 개인 사용 영역에 슬롯을 할당했기 때문입니다. 그런 다음 4.1에서
      유니코드는 표준에 글리프를 추가했습니다.

.. _faq.non-integral:

**정수가 아닌 좌표를 사용해도 안전한가요?**
   FontForge는 정수가 아닌 좌표로 편집할 수 있습니다. 많은 폰트 편집기는
   그렇지 않으며 일부는 정수가 아닌 좌표를 사용하면 래스터화될 때
   폰트가 왜곡될지 궁금해했습니다.

   대답은 폰트 형식과 폰트를 저장하는 방법에 따라 다릅니다.

   TrueType 폰트는 정수 좌표만 표현할 수 있습니다. FontForge가 TrueType
   폰트를 만들 때 모든 좌표를 정수로 반올림합니다. 이 반올림은 곡선에
   약간의 왜곡을 유발합니다.

   PostScript(type1, PostScript OpenType, type2 등) 폰트는 폰트 형식에서
   정수가 아닌 좌표를 표현할 수 있지만 폰트 파일에서 훨씬 더 많은 공간을
   차지합니다. Type1 폰트는 type2(opentype) 폰트보다 이것을 표현하는 데
   더 많은 공간을 차지하는 경향이 있습니다. 기본적으로 FontForge는 이것들도
   정수로 반올림하지만 생성 옵션 대화 상자에서 변경할 수 있습니다.

   폰트가 반올림되면 약간의 왜곡이 있습니다. 반올림되지 않으면 왜곡이
   없어야 합니다. PostScript 폰트에서는 폰트를 생성할 때 반올림을 끄면
   정수가 아닌 좌표를 사용해도 안전해야 합니다. 폰트 파일은 더 커지지만
   더 정확해집니다.

   TrueType에서 더 많은 정확도가 필요하다고 생각되면 em 크기를 8096으로
   변경할 수 있습니다.

   PostScript Type1 폰트에서도 이 작업을 수행할 수 있지만, 모든 OpenType
   postscript 폰트의 em 크기가 1000이라고 가정하는 일부 응용 프로그램이
   있으므로 OpenType 출력에는 이 작업을 수행하지 않는 것이 가장 좋습니다.

.. _faq.Open-size:

**왜 제 Open Type 폰트가 .pfb 파일보다 훨씬 작지 않나요?**
   이것은 아마도 폰트를 저장하기 전에 정수로 반올림하지 않았기 때문일
   것입니다. FontForge는 일반 정수보다 훨씬 더 많은 공간을 차지하는
   고정 소수점 숫자를 사용하여 폰트를 저장합니다.

.. _faq.Open-difference:

**OpenType과 PostScript(또는 TrueType) 폰트의 차이점은 무엇인가요?**
   PostScript와 TrueType는 모두 파일 형식과 글리프 형식을 정의합니다.
   OpenType은 PostScript 글리프 형식과 함께 TrueType 파일 형식을
   사용합니다(실제로 OpenType에는 TrueType 글리프 형식도 포함되지만,
   OpenType 정의에서는 이러한 폰트를 여전히 TrueType 폰트라고 불러야
   한다고 하므로 그 측면은 무시합니다).

   OpenType에서 사용되는 PostScript는 .pfa 및 .pfb 파일에서 사용되는
   것과 약간 다릅니다. pfa/b 파일은 Type1 폰트이고 OpenType은 Type2
   폰트를 사용합니다. Type2는 몇 가지 사소한 변경 사항과 많은 확장을
   가진 Type1의 거의 상위 집합입니다. Adobe의 Type1에 대한 서브루틴 기반
   확장(flex 힌트, 힌트 대체, 카운터 힌트)은 직접 지침으로 Type2에
   추가되었습니다.

   OpenType은 또한 복잡한 스크립트(아랍어, 인도어 등)의 레이아웃을 허용하는
   추가 정보(:ref:`아래 <faq.AAT-Open>` 참조)와 글리프 변형 및 기타
   세부 타이포그래피 측면에 대한 지원을 포함할 수 있습니다.

.. _faq.AAT-Open:

**AAT(Apple Advanced Typography)와 OpenType의 차이점은 무엇인가요?**
   이 두 가지 모두 복잡한 스크립트(아랍어 또는 인도어 스크립트와 같은)를
   레이아웃하기 위한 정보와 글리프 변형 및 기타 정교한 타이포그래피 측면을
   지원할 수 있는 기본 TrueType 폰트에 대한 확장입니다. 이 작업의 더 복잡한
   측면을 위해 완전히 다른 내부 형식을 사용하며, 이 형식은 다른 표현력을
   가지고 있어 어느 형식도 일부 정보 손실 가능성 없이 다른 형식으로 변환할
   수 없습니다. 이에 대해 더 자세히 설명합니다.

   * :doc:`튜토리얼 </tutorial/editexample6-5>`에서
   * :doc:`고급 타이포그래피에 대한 섹션 </techref/gposgsub>`에서

.. _faq.Tiger-Open:

**10.3에서 잘 작동하던 폰트가 Mac 10.4(Tiger)에서 실패하는 이유는 무엇인가요?**
   Tiger(Mac OS/X.4)에서 Apple은 OpenType에 대한 일부 지원을 추가했습니다.
   일부 OpenType 기능은 (런타임에) AAT 기능으로 변환됩니다. 이것은 좋지만
   모든 기능에 해당하는 Apple 기능/설정이 있는 것은 아니며 모든 조회가
   변환될 수 있는 것도 아닙니다(조건부 조회는 변환할 수 없음). 불행히도
   폰트에 OpenType과 AAT 기능이 모두 포함되어 있으면 Apple은 이제 AAT
   기능을 무시합니다(또는 그렇게 들었습니다). 그 결과 아마도 작동할
   AAT 기능이 사용되지 않고, 완전히 지원되지 않아 작동하지 않을 OpenType
   기능이 대신 사용됩니다.

.. _faq.save-no-change:

**폰트를 생성하고 종료한 후 왜 FontForge가 폰트를 저장할지 묻나요? 아무것도 변경하지 않았습니다.**
   이것이 발생하는 데는 두 가지 이유가 있을 수 있습니다.

   #. 이 세션에서 아무것도 변경하지 않았더라도 FontForge는 하나 또는 여러
      글리프에 대한 힌트 정보를 (재)생성해야 할 수 있습니다(예를 들어
      해당 글리프가 (이전 세션에서) 변경되었지만 그 이후로 힌트가
      생성되지 않은 경우). 이러한 새 힌트는 폰트를 변경된 것으로 표시합니다.
   #. 폰트 정보에 XUID 필드가 있는 경우 FontForge는 포스트스크립트 폰트가
      생성될 때마다 XUID의 마지막 숫자를 증가시킵니다 -- 이것도 변경으로
      간주됩니다. (왜 FontForge가 이 작업을 수행하나요? Adobe가 그렇게
      해야 한다고 말했기 때문입니다. 사소한 불편함이지만, 이전 버전의
      폰트를 새 버전으로 변경할 때 폰트 캐싱 문제를 피할 수 있습니다.)

.. _faq.TeX:

**왜 TeX가 제 폰트에서 작동하지 않나요?**
   저는 TeX에 대해 완전히 초보입니다. TeX(또는 TeX 체인의 일부, 아마도
   dvips)는 폰트가 TeX 기본 인코딩으로 인코딩되기를 기대한다고 들었습니다 --
   때로는 TeX 문서에서 "Adobe Standard"라고 불리지만, 그것은 TeX 기본입니다.
   따라서 인쇄 문제, 누락된 글리프 등이 있는 경우 폰트의 인코딩을 TeX
   기본으로 변경해 보십시오(:menuselection:`요소 --> 폰트 정보`로 이동하여
   인코딩 탭을 선택하고 풀다운 목록에서 TeX 기본을 선택).

.. _faq.mf-files:

**왜 FontForge에서 '.mf' 파일을 편집할 수 없나요?**
   Knuth가 말했듯이 "(WSYWYG의 문제는...) 당신이 보는 것이 *전부*라는
   것입니다." FontForge도 이 문제를 겪습니다.

   간단한 예를 들어 보겠습니다. 다음과 같이 정의된 점이 있다고 가정해
   봅시다.

   .. parsed-literal::

      top\ :sub:`1`\ y\ :sub:`2` = CapHeight

   그리고 사용자는 점 2를 새 y 위치로 드래그하려고 합니다. FontForge는
   이것을 어떻게 해석해야 할까요? 다음과 같이 할 수 있습니다.

   * ``CapHeight`` 변경
   * 펜 1의 너비 변경
   * 방정식을 다음과 같이 변경:

     .. parsed-literal::

        top\ :sub:`1`\ y\ :sub:`2` = CapHeight - 30

   * 또는 다음과 같이:

     .. parsed-literal::

        top\ :sub:`1`\ y\ :sub:`2` = (CapHeight + XHeight)/2

   * 또는 다른 6가지 방법으로.

   따라서 FontForge의 점 이동 방법은 모호합니다. 그리고 저는 그것을
   명확하게 하는 합리적인 방법을 생각해 내지 못했습니다. 제안은 환영합니다
   (하지만 구현될 것이라는 보장은 없습니다).

.. _faq.minify-iconify:

**뷰를 최소화하려고 할 때 왜 창이 아이콘화되나요?**
   일부 창 관리자(예: gnome-sawtooth)는 FontForge에서 메타(alt) 클릭을
   가로챕니다. 따라서 글리프를 최소화하기 위해 메타-중간-클릭을 사용할
   수 없으며, 대신 :menuselection:`보기 메뉴 --> 축소`를 사용해야 합니다.

.. _faq.no-mu:

**왜 제 그리스어 폰트에 "mu"라는 문자가 없나요?**
   Adobe는 유니코드 인코딩에서 그리스 문자의 이름을 할당할 때 의미보다
   이전 버전과의 호환성을 더 많이 생각했습니다. 따라서 "mu"라는 이름은
   뮤 문자가 아닌 마이크로 기호(U+00B5)를 나타냅니다. 또한 델타를 증분으로,
   오메가를 옴 기호로 할당했습니다.

   Adobe는 또한 U+03D6(유니코드 컨소시엄에서 "GREEK PI SYMBOL"이라고 함)의
   문자를 "omega1"이라고 명명하기로 결정했는데, "pi1"이 더 적절해 보입니다.

.. _faq.no-copy-names:

**왜** :menuselection:`편집 --> 복사` **가 글리프 정보뿐만 아니라 글리프 이름도 복사하지 않나요?**
   첫째, 글리프 이름을 복사하려는 모든 시도는 거의 확실하게 사용자 정의
   :doc:`인코딩 </ui/menus/encodingmenu>`을 정의하여 더 잘 수행될 것이라고
   믿기 때문입니다.

   둘째, 대부분의 경우 이름이 복사되기를 원하지 않기 때문입니다.

   셋째, 복사는 데이터만으로 작동하고 메타데이터로는 작동하지 않는 것이
   미학적으로 더 좋기 때문입니다.

   하지만... 이 질문을 한 사람들이 충분히 많아서 :ref:`편집->복사->문자
   이름 <editmenu.CharName>`에 기본 동작을 변경할 수 있는 모드를
   활성화했습니다.

.. _faq.copy-names:

**왜** :menuselection:`편집 --> 붙여넣기` **가 이름 중복에 대해 불평하나요?**
   :menuselection:`편집 --> 복사 --> 메타데이터 복사`가 선택되어 있기
   때문입니다. 선택을 해제하십시오.

.. _faq.disabled-build-menu:

**왜** ::menuselection:`요소 --> 빌드` **가 비활성화(또는 회색)되어 있나요?**
   cacute(ć)와 같은 글리프를 클릭하고 :menuselection:`요소 --> 빌드 -->
   강조된 글리프 빌드`를 사용하여 이 글리프를 빌드하려면 두 가지가 필요합니다.
   문자 c와 '. 더 구체적으로: **COMBINING ACUTE ACCENT**이 필요합니다(**MODIFIER
   LETTER ACUTE ACCENT**뿐만 아니라). 수정자 글리프는 원이 있는 섹션에서
   찾을 수 있습니다. 둘 다 있으면 옵션이 활성화됩니다.

   글리프의 요구 사항을 어떻게 알 수 있나요?
   :menuselection:`요소 --> 글리프 정보...` 왼쪽에서 구성 요소로 이동합니다.
   Fontforge는 강조된 글리프가 무엇으로 구성되어 있는지 설명합니다.

.. _faq.cidmaps:

**cidmap 파일은 도대체 무엇이며 신경 써야 하나요?**
   배경 정보:

   포스트스크립트가 발명되었을 때 폰트의 모든 글리프에는 이름과 256개
   요소 배열로 지정된 인코딩이 주어졌습니다. 이 배열은 문자 코드를 이름에
   매핑했습니다.

   그런 다음 그들은 CJK 폰트(그리고 아마도 유니코드)에 대해 생각하기
   시작했는데, 이것들은 거대한 글리프 세트를 가지고 있으며 10,000개의
   글리프에 대해 합리적인 ASCII 이름을 생각해 내는 것은 :small:`a)` 공간
   낭비이고, :small:`b)` 거의 의미가 없었습니다. 그래서 adobe는 글리프
   이름과 인코딩이 없는 CID 키 폰트를 만들었습니다. 모든 글리프에는
   인덱스(CID)가 있으며, 이것은 단지 숫자이며, 이것은 이름처럼 취급됩니다.
   그런 다음 폰트 외부에 폰트의 인코딩을 제공하는 추가 리소스(cmap)가
   있으며(SJIS와 같은 정말 지저분한 인코딩 체계를 지원할 수 있음), 입력
   바이트 시퀀스를 CID에 매핑합니다.

   Adobe는 특정 표준 cmap 리소스(예: SJIS용, JIS용, 확장 유닉스용)를
   제공합니다. 이러한 파일은 작성하기가 상당히 고통스럽기 때문에 Adobe는
   모든 사람이 동일한 cmap 파일을 사용할 수 있도록 CID에 표준 의미를
   할당했습니다. -- 음, 실제로는 5~6개의 다른 표준이 있습니다. 일본어(JIS208),
   일본어(JIS212), 한국어, 중국어(홍콩, 대만), 중국어(본토, 싱가포르),
   Identity(유니코드) -- 그래서 CID 1은 공백일 수 있고, CID 2는 "!"일 수
   있고, CID 935는 "가타카나 카"일 수 있습니다.

   제 cidmap 파일은 Adobe의 CID와 유니코드 간의 매핑만 제공합니다. 이를
   통해 FontForge는 어떤 글리프를 작업하고 있는지 알 수 있습니다. 이것들이
   없어도 정상적으로 작동해야 하지만, FontForge는 폰트 뷰를 적절한
   글리프 대신 "?"로 채울 것입니다. 그리고 FontForge는 폰트를 유니코드나
   다른 것으로 다시 인코딩할 수 없을 것입니다.

   따라서 cidmap 파일은 CID 키 CJK 폰트에서 작업하는 사람들에게만
   유용합니다. 따라서 많은 유럽인/미국인은 필요하지 않을 것입니다.

.. _faq.simplify:

**단순화 명령이 정확도를 잃나요?**
   예, 그렇습니다.

   하지만 많이는 아닙니다.

   스플라인 세트를 원래 스플라인과 로컬 좌표계에서 한 단위 이상 차이가 나지
   않는 다른 스플라인으로 대체하도록 설계되었습니다.

   이 정도의 정확도가 충분하지 않은 경우(아웃라인 뷰에서):

   * :menuselection:`편집 --> 선택 --> 모두 선택`
   * :menuselection:`요소 --> 변환 --> 변환`
   * 균일하게 크기 조정: 1000%
   * 확인
   * 단순화
   * :menuselection:`요소 --> 변환 --> 변환`
   * 균일하게 크기 조정: 10%
   * 확인

   이것은 스플라인 세트를 원래 스플라인과 0.1 단위 이상 차이가 나지 않는
   스플라인으로 대체합니다.

.. _faq.cubic-quadratic:

**FontForge는 3차 스플라인을 truetype용 2차 스플라인으로 어떻게 변환하나요?**
   다시 말하지만 이것은 정확도 손실을 수반할 수 있습니다.

   먼저 FontForge는 스플라인이 이미 2차인지 확인합니다(이것은 방금
   truetype 폰트를 읽었거나 스플라인을 생성할 때 기적이 일어났을 때
   발생합니다).

   그렇지 않으면 FontForge는 원래 스플라인을 더 작은 덩어리로 나누고
   어디에서든 3차와 1단위 이상 차이가 나지 않는 2차 스플라인 세트를
   찾으려고 합니다. (두 끝점을 선택하고 해당 끝점의 기울기를 알면
   두 점 사이에 가능한 2차 스플라인은 하나뿐입니다.)

.. _faq.quadratic-cubic:

**FontForge는 2차 스플라인을 3차로 어떻게 변환하나요(truetype 읽을 때)?**
   이것은 모든 2차 스플라인이 이미 3차로 표현될 수 있기 때문에 쉽습니다.
   단지 3차 항이 항상 0이 될 뿐입니다.

   아마도 제어점은 더 이상 정수 좌표에 있지 않을 것이고 3차 형식으로
   저장될 때 정밀도 손실이 있을 것입니다.

.. _faq.complex-eps:

**왜 fontforge가 "EPS 파일이 너무 복잡해서 이해할 수 없습니다"라고 말하나요?**
   (음, 셰익스피어의 인용을 잘못 인용한 것이기 때문입니다. 어떻게 그걸
   놓칠 수 있겠습니까? *헛소동, V . i. 217*)

   eps 파일을 로드하는 대부분의 프로그램은 그것들을 블랙박스로 취급합니다.
   파일을 메모리로 읽고 변경하지 않고 포스트스크립트 프린터로 출력합니다.
   불행히도 FontForge는 이것을 할 수 없습니다. FontForge는 eps 파일을
   이해한 다음 더 간단한 형식으로 변환해야 합니다(폰트는 eps 파일보다
   훨씬 적은 작업을 사용할 수 있습니다). 따라서 대부분의 프로그램과 달리
   FontForge는 각 eps 파일을 해석해야 하지만 모든 PostScript를 해석하는
   것은 엄청난 작업이며 ff가 이해하는 데는 한계가 있습니다. 때로는 처리할
   수 없는 파일을 찾을 수도 있습니다.

.. _faq.Inkscape:

**Inkscape에서 글리프 가져오기**
   (`OSPublish 블로그 <http://ospublish.constantvzw.org/?p=340>`__에서 가져와
   Dave Crossland가 다시 씀)

   Inkscape에서 글리프를 디자인하여 fontforge로 쉽게 가져오는 방법.

   * Inkscape 열기
   * 파일 메뉴에서 문서 속성을 선택합니다.
   * 단위를 픽셀(px)로 설정하고 문서 크기를 1000 x 1000으로 설정한 다음 확인을 클릭합니다.

     :small:`또는 폰트에 em당 단위 수가 다른 경우 해당 값을 사용하지만 1000이
     fontforge의 기본값입니다.)`
   * 200px에 수평 가이드를 설정합니다.
   * 글리프 그리기 - 가장 어려운 부분! :-)
   * 그림을 SVG 파일로 저장합니다.
   * FontForge 열기
   * 파일 메뉴에서 가져오기를 선택하고 SVG를 선택한 다음 그림을 찾아 확인을 클릭합니다.
   * 요소 메뉴에서 변환을 선택하고 Y 값을 -200으로 설정한 다음 확인을 클릭합니다.

.. _faq.default-char:

**폰트의 기본 글리프를 어떻게 설정하나요?**
   ".notdef"라는 이름의 글리프에 일부 스플라인(참조 없음)이 포함되어 있으면
   기본 글리프(인코딩되지 않은 글리프가 호출될 때 사용되는 글리프)로
   사용됩니다.

   단, OpenType 폰트(즉, PostScript OpenType 폰트)에서는 .notdef
   글리프가 기본 글리프로 사용되지 않고 대신 "space" 글리프가 사용됩니다.
   (저를 보지 마세요. 제가 사양을 쓴 게 아닙니다.)

.. _faq.ttf-degrade:

**ttf 폰트를 로드하고 몇 가지 변경한 후 새 폰트를 생성했습니다. 변경된 글리프가 원본만큼 보기 좋지 않습니다. 왜 그런가요?**
   FontForge가 truetype 폰트를 읽을 때 원본에 있던 모든 힌트(지침)를
   저장합니다. 하지만 글리프를 어떤 중요한 방식으로든 변경하면 해당
   지침은 더 이상 유효하지 않으므로(외곽선의 세부 사항에 밀접하게 의존함),
   변경할 때 FontForge가 제거합니다. 그 결과 FontForge로 글리프를 변경하면
   대부분의 truetype 폰트에서 외관이 저하됩니다(전부는 아님, 일부는 힌트가
   없음).

   FontForge는 직접 truetype 지침을 생성할 수 있지만, 그렇게 하도록
   요청해야 합니다 -- :menuselection:`힌트 --> 자동 지침` 명령을 사용하십시오.

.. _faq.otf-diffs:

**opentype 폰트를 생성했는데 windows에서 설치되지 않았습니다. 왜 그런가요?**
   불행히도 Apple과 MicroSoft(및 Adobe)는 open 및 truetype 폰트의 적절한
   형식에 대해 동의하지 않습니다. FontForge에는 폰트 생성 옵션 대화 상자에
   [] Apple이라는 확인란이 있습니다. Mac용 폰트를 생성할 때는 이것이
   선택되어 있는지 확인하십시오. Windows용(그리고 아마도 unix용도, unix는
   덜 까다로운 경향이 있음) 폰트를 생성할 때는 이것이 선택되어 있지 않은지
   확인하십시오.

   지금까지 제가 우연히 발견한 주요 차이점은 다음과 같습니다.

   * NAME 테이블의 포스트스크립트 이름 항목.

     (이것은 실제로 Apple 버전의 사양 오류이며, Mac의 동작은 Windows의
     동작과 일치한다고 들었습니다.)
   * 비트맵 폰트를 포함하는 테이블의 이름
   * 크기 조절된 참조가 저장되는 방식
   * 그리고 고급 타이포그래피 기능을 포함하는 테이블은 완전히 다릅니다.

.. _faq.DSIG:

**opentype 테이블이 있는 truetype 폰트가 있는데 windows에서 "TT"(truetype) 아이콘이 아닌 "O" 아이콘을 표시합니다. 왜 그런가요?**
   제가 아는 한 Windows는 'DSIG'(디지털 서명) 테이블이 포함된 truetype
   폰트에 "O" 아이콘을 표시합니다. FontForge는 디지털 서명을 생성하지
   않습니다(저는 그것들이 부정적인 유용성을 가지고 있다고 생각하며, 어쨌든
   어떻게 만드는지 모릅니다).

   그러나 서명이 없는 'DSIG' 테이블을
   :ref:`FontForge에 생성하도록 요청 <generate.Options>`할 수 있습니다.
   그것만으로도 windows를 만족시키는 데 충분한 것 같습니다.

.. _faq.names:

**다양한 폰트 이름은 무엇을 의미하나요?**
   :menuselection:`요소 --> 폰트 정보`를 열면 여러 다른 필드가 있는 이름
   창이 표시됩니다. 왜 그렇게 많고 모두 무엇을 의미하나요?

   이름 창에는 PostScript 폰트에서 사용되는 이름이 포함되어 있습니다.
   sfnt(sfnt는 truetype, opentype 및 더 모호한 여러 폰트 형식을 포함하는
   폰트 파일 형식임)에서 사용되는 유사한 이름 세트를 포함하는 ``TTF 이름``
   창도 있습니다.

   폰트는 sfnt에 래핑된 PostScript일 수 있습니다. 이 경우 PostScript
   이름 세트와 sfnt(ttf) 이름 세트를 모두 가질 수 있습니다. 해당 이름은
   다를 수 있습니다(일반적으로 좋은 생각은 아니지만 *가능*합니다).

   "사람을 위한 이름"은 전통적으로 폰트와 관련된 이름입니다. "ITC New
   Century Schoolbook Italic #4"와 같은 것일 수 있습니다. 응용 프로그램이
   사람들에게 폰트가 무엇인지 알리고 싶을 때 표시하는 데 사용할 수 있는
   문자열입니다.

   fontname은 PostScript가 프로그래밍 언어이고 이것이 PostScript 내에서
   폰트를 식별하는 데 사용되는 이름이기 때문에 존재합니다. 이름에 있을
   수 있는 문자에 제한이 있습니다(공백이 가장 큼. 하지만 숫자처럼 보일
   수도 없고, 괄호 등도 안 됨) 및 이름 길이에 대한 제한이 있습니다.
   "ITCNewCenturySchoolbook-Italic"과 같을 수 있습니다.

   패밀리 이름은 관련 폰트 패밀리의 이름입니다. 위 예에서 "ITC New
   Century Schoolbook"이 아마도 패밀리 이름일 것입니다.

   "기본 파일 이름"은 폰트 자체와 관련된 이름이 아닙니다. fontforge를
   사용할 때 삶을 더 쉽게 만들기 위해 그냥 있는 것입니다. 폰트를 생성할
   때 ff는 기본 파일 이름을 선택합니다(물론 언제든지 변경할 수 있지만,
   기본 이름이 사용하려는 이름이면 편리합니다).

   일반적으로 기본 이름은 확장자가 추가된 fontname일 뿐입니다
   (ITCNewCenturySchoolbook-Italic.ttf). 하지만 때로는 사람들이 기본
   이름을 다르게 원할 수도 있습니다. 아마도 NewCentSchlBk-Ital.ttf와
   같이요. 이것은 그렇게 할 수 있게 해줍니다.

   따라서 폰트를 포함하는 파일의 기본 FILENAME을 제어하며, 폰트 자체의
   어떤 것과도 직접 관련이 없습니다.

   가중치 문자열은 "Bold", "Black", "Thin" 등과 같은 것입니다. 다른
   스타일 변형은 포함하지 않습니다(여기에 Italic 또는 Condensed를 넣지
   않습니다).

   저작권 문자열은 자명해야 합니다.

--------------------------------------------------------------------------------

   폰트 정보의 "이름" 창 외에도 TTF 이름 창이 있습니다.

   여러 면에서 이것은 이름 창의 복제이지만 몇 가지 차이점이 있습니다.
   sfnt의 이름을 지정하는 데 사용됩니다.

   여기에는 다음이 있습니다.

   * 패밀리

     이것은 PostScript 패밀리에 해당합니다.
   * 서브패밀리

     가중치 필드와 막연하게 비슷하지만 가중치뿐만 아니라 모든 스타일
     변형을 사용합니다.

     이것은 "Bold", "Italic", "Bold Italic", "SemiBold", "Condensed", ...

     폰트에 적합한 모든 것일 수 있습니다.
   * 전체 이름

     이것은 "사람을 위한 이름"에 해당합니다.
   * 저작권

   일반적으로 FontForge는 이러한 모든 필드를 적절하게 설정합니다(즉, 이름
   창과 동일). ff가 선택한 이름이 마음에 들지 않으면 항목을 마우스 오른쪽
   버튼으로 클릭하고 팝업 메뉴에서 선택하여 PS 이름과 연결을 끊을 수
   있습니다.

--------------------------------------------------------------------------------

   더 복잡하게 만드는 필드가 있습니다.

   * WWS 패밀리
   * WWS 서브패밀리

   저는 이것들이 왜 필요한지 정말 이해하지 못하지만, MicroSoft는 필요하다고
   생각합니다. 제가 아는 한, 이것들은 (대부분의 경우) 위의 패밀리 및
   서브패밀리와 동일해야 하므로 생략해야 합니다.

--------------------------------------------------------------------------------

   CID fontname은 CID 키 폰트를 빌드하지 않는 한 무시해야 합니다(보통
   CJK 폰트에서 작업하고 있음을 의미).

--------------------------------------------------------------------------------

   호환되는 전체 이름

   제가 필요성을 느끼지 못하는 또 다른 이름입니다. 저는 이것이 전체 이름과
   동일해야 한다고 생각하며 생략해야 합니다.

--------------------------------------------------------------------------------

   TTF 이름은 둘 이상의 언어 및 쓰기 시스템으로 지정될 수 있습니다. 가장
   자주 번역되는 항목은 서브패밀리입니다. 따라서 이탤릭 폰트의 경우
   영어 항목 "Italic"과 아마도

   * 프랑스어, Italique
   * 독일어, Kursiv
   * 네덜란드어, Cursief

   등이 있을 것입니다.

.. _faq.mingliu:

**kaiu.ttf 또는 mingliu.ttf를 봤는데 외곽선이 올바른 글리프와 전혀 닮지 않았습니다. 무엇이 잘못되었나요?**
   일부 트루타입 폰트(kaiu와 mingliu가 예)는 올바른 외곽선을 저장하지
   않습니다. 대신 지침을 사용하여 점을 이동하여 외곽선을 생성하는 데
   의존합니다. 외곽선은 전혀 그리드에 맞춰진 것처럼 보이지 않고 그냥
   배치된 것처럼 보입니다. FontForge는 폰트를 읽을 때 지침을 처리하지
   않습니다. 대부분의 폰트에서 이것은 잘못된 일이 될 것이며, 언제 해야
   하는지 어떻게 알 수 있는지 모르겠습니다...

.. _faq.greek-accents:

**요소 --> 빌드 --> 강조된 글리프 빌드를 사용하여 확장 그리스 글리프(U+1F00-U+1FFF) 중 하나를 빌드할 때 FontForge가 잘못된 강조를 선택합니다. 왜 그런가요?**
   어떤 이유로 유니코드는 그리스어와 라틴어 악센트가 전혀 비슷하지 않음에도
   불구하고 통합했습니다. FontForge가 단순한 유니코드 정의를 따를 때
   그리스어 글리프에 대해 라틴어 악센트를 선택할 가능성이 높습니다.
   다행히도 유니코드에는 U+1FBD 주변에서 시작하는 그리스어 악센트에 대한
   코드 포인트도 포함되어 있습니다. 이러한 코드 포인트를 적절한 악센트로
   채우면 FontForge는 라틴어 악센트 대신 이것들을 사용합니다.

.. _faq.u-accents:

**요소 --> 빌드 --> 강조된 글리프 빌드를 사용하여 "u" 또는 "y" 위에 강조를 빌드할 때 글리프 중앙이 아닌 스템 중 하나 위에 강조가 표시됩니다. 왜 그런가요?**
   스템 중 하나가 다른 것보다 약간 더 큽니다. FontForge는 글리프에서
   가장 높은 점 위에 악센트를 중앙에 배치합니다. 동일한 높이를 가진 여러
   점이 있는 경우 평균이 사용됩니다.

   모든 스템을 동일한 높이로 만들면 악센트가 올바르게 중앙에 배치되어야
   합니다.

.. _faq.remove-overlap:

**요소 --> 겹침 --> 겹침 제거를 사용할 때 겹치는 부분에서 글리프가 반전(또는 흰색)됩니다. 왜 그런가요?**
   결합하는 경로가 반대 방향으로 정렬되어 있기 때문입니다. 글리프를
   뒤집고 결합하려고 했을 수 있습니다. 해결책은 매우 간단합니다. 문제가
   되는 모양을 선택한 다음 :menuselection:`요소 --> 방향 반전`을 선택합니다.

.. _faq.ttf2afm:

**왜 ttf2afm이 FontForge ttf 파일에서 충돌하나요?**
   모르겠습니다. 제 redhat 7.3 linux와 함께 배포된 ttf2afm은 확실히
   충돌했습니다. ctan의 `pdftex <http://www.ctan.org/tex-archive/obsolete/systems/pdftex/>`__
   영역에서 소스를 다운로드하고 (디버그로) 빌드했을 때 결과 프로그램은
   충돌하지 않았습니다. 따라서 저는 이것이 ttf2afm의 버그이며 해당 버그가
   수정되었다고 생각합니다.

   ttf2afm에서 생성된 afm 파일은 `Adobe의 사양
   <http://partners.adobe.com/asn/developer/PDFS/TN/5004.AFM_Spec.pdf>`__에
   부합하지 않습니다.

.. _faq.memory:

**FontForge가 메모리 부족으로 계속 충돌합니다. 어떻게 해야 하나요?**
   메모리를 더 사세요?

   큰 폰트를 편집하는 경우 FontForge가 메모리 부족에 직면할 수 있습니다.
   FF가 메모리 부족에 직면하면 커널이 오류 조건을 보고하는 대신 충돌하는
   경우가 너무 많습니다. FontForge는 할당 실패를 확인하고 시스템이 오류를
   반환할 때 일부 메모리 청크를 해제하려고 시도합니다 -- 하지만 이 코드가
   활성화되는 것을 본 적이 없습니다.

   FontForge는 이것을 피하는 데 도움이 될 수 있는 메커니즘을 제공합니다.
   FontForge는 일반적으로 실행 취소를 유지하는 데 많은 메모리를 낭비합니다.
   :menuselection:`편집 --> 실행 취소 제거` 명령으로 글리프와 관련된
   실행 취소를 지울 수 있습니다. 또한 :menuselection:`파일 --> 기본 설정
   --> 편집 --> 실행 취소 깊이`로 각 글리프에 저장될 실행 취소 수를
   제한할 수 있습니다.

.. _faq.Unstable:

**왜 FontForge는 그렇게 불안정한가요?**
   저는 QA를 하는 것에 별로 신경 쓰지 않습니다. 이것은 문제입니다. 저는
   그것을 즐기지 않고, 아무도 저에게 돈을 주지 않으므로 거의 이루어지지
   않습니다.

   `QA에 자원하고 싶다면 알려주세요
   <mailto:fontforge-devel@lists.sourceforge.net>`__(이것은 공개 메일링
   리스트입니다). 보람 없는 일이지만 중요합니다!

.. _faq.Compiz:

**왜 FontForge는 Xgl/Compiz에서 보기 흉하게 보이나요?**
   저는 전혀 모르겠지만, 다음과 같이 설정하면 해결할 수 있다고 들었습니다.

      XLIB_SKIP_ARGB_VISUALS=1

   FontForge용.

.. _faq.talk:

**왜 제가 컨퍼런스에서 발표하지 않나요?**

   .. epigraph::

      | **타이슨:**
      | 저는
      | 찾을 수 없습니다. 저는 다른 곳에서 완전히 바쁩니다.
      | 저를 찾고 싶으시면 제 서재에 있을 것입니다.
      | 노크할 수 있지만 대답하지 않을 것입니다.
      | 제 신념과 함께 혼자 있고 싶습니다.
      | 안녕히 주무세요. *[퇴장]*

      -- *The Lady's not for Burning* -- 크리스토퍼 프라이

   할 말이 없기 때문입니다.

.. container:: clearer

   ..

--------------------------------------------------------------------------------

.. epigraph::

   | 위대한 질문에 대한 대답은...?
   | 예...!
   | ...입니다.
   | 예...!
   | ...입니다.
   | 예...!!!...?
   | "42," 딥 쏘트가 무한한 위엄과 평온함으로 말했다.
   | "42!" 룬퀄이 소리쳤다. "750만 년의 작업 끝에 보여줄 게 그것뿐인가?"

   "저는 매우 철저하게 확인했습니다." 컴퓨터가 말했다. "그리고 그것이
   확실히 대답입니다. 솔직히 말해서 문제는 당신이 실제로 질문이
   무엇인지 전혀 몰랐다는 것입니다."

   -- 은하수를 여행하는 히치하이커를 위한 안내서

.. epigraph::

   모두 플라톤에 있어, 모두 플라톤에: 세상에, 이 학교에서 뭘 가르치는 거야?

   -- *마지막 전투* -- C.S. 루이스

.. epigraph::

   | "나는 세 가지 질문에 대답했고, 그것으로 충분하다."
   | 아버지가 말했다. "잘난 척하지 마!
   | 하루 종일 그런 말을 들을 수 있다고 생각하니?
   | 꺼져, 아니면 계단 아래로 걷어차 버릴 테다."

   -- *당신은 늙었어, 윌리엄 신부* -- 루이스 캐럴
