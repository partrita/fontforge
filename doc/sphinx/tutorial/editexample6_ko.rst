글리프 변형 및 앵커링 마크
==================================


글리프 변형
--------------

많은 스크립트에서 글리프에는 여러 변형 글리프가 있습니다. 라틴어에서 가장 확실한 예는 모든 문자에 대문자와 소문자 변형이 있다는 것입니다. 더 난해한 예는 르네상스 시대에 긴 s 변형이 단어의 시작과 중간에 사용되었고 짧은 s는 단어 끝에만 사용되었다는 것입니다.

대부분의 아랍어 글리프에는 네 가지 변형(초성, 중성, 종성 및 독립형)이 있습니다.

숫자에는 종종 여러 변형이 있습니다. 표 형식 숫자(모든 숫자의 너비가 같아 숫자 표가 들쭉날쭉해 보이지 않음), 비례 숫자(각 숫자의 모양에 맞는 너비를 가짐) 및 구식 또는 소문자 숫자(|lcdigits|)가 있으며 일부 숫자에는 디센더가 있고 다른 숫자에는 어센더가 있습니다.

.. |lcdigits| image:: /images/lcdigits.png

이러한 변형 중 일부는 인코딩에 내장되어 있지만(대문자와 소문자 구별), 다른 경우에는 워드 프로세서가 변형을 인식할 수 있도록 글꼴에 추가 정보를 제공해야 합니다(아랍어는 둘 사이의 중간에 있으며 다양한 형식이 인코딩에 있지만 추가 정보도 제공해야 함).

.. image:: /images/subtable-oldstyle.png
   :align: right

위에서 언급한 숫자의 경우를 생각해 봅시다. "one"이라는 글리프에는 1의 표 형식 변형이, "one.prop" 글리프에는 비례 변형이, "one.oldstyle"에는 소문자 변형이 포함되어 있다고 가정하고 다른 모든 숫자도 마찬가지입니다. 다른 작업을 하기 전에 두 개의 :ref:`조회 <editexample4.lookups>` 및 관련 하위 테이블을 만들어야 합니다(다시 설명하지 않겠습니다. 여기서 조회 유형은 "단일 대체"이고 기능은 비례 숫자의 경우 "pnum", 구식 숫자의 경우 "onum"입니다. 또한 숫자는 단일 스크립트에 있지 않고 여러 스크립트에 있으므로 이 기능을 여러 스크립트("DFLT" 포함)에 적용하십시오.

FontForge가 구식 조회 하위 테이블을 채우기 위한 대화 상자를 표시하면 접미사가 포함된 텍스트 필드 뒤에 [접미사를 사용하여 기본값:] 버튼이 있습니다. 텍스트 필드를 "oldstyle"로 설정하고 버튼을 누릅니다. 그러면 기능의 모든 스크립트에 있는 모든 글리프를 검색하여 "oldstyle" 변형을 찾아 테이블을 채웁니다.

.. image:: /images/glyphinfo-one.png
   :align: left

때로는 특정 글리프에 사용할 수 있는 모든 대체를 생각하는 것이 더 합리적일 수 있습니다(특정 조회의 모든 대체가 아니라). 따라서 "비례 숫자"에 대한 하위 테이블 대화 상자를 채우는 대신 글꼴 보기에서 "one"을 선택하고 :ref:`요소->글리프 정보 <charinfo.substitution>`, ``대체`` 탭을 선택하고 ``<새로 만들기>`` 버튼을 누릅니다.

(참고: Type0, Type1 및 Type3 PostScript 글꼴에는 이를 처리할 표기법이 없습니다. 이러한 변형을 출력하려면 OpenType 또는 TrueType 글꼴을 만들어야 합니다.)


.. _editexample6.Conditional:

조건부 변형
^^^^^^^^^^^^^^^^^^^^

FontForge는 OpenType의 컨텍스트 대체 및 체인 컨텍스트 대체 하위 테이블과 어느 정도는 Apple의 컨텍스트 글리프 대체 하위 테이블을 지원합니다. 이것은 글꼴에 조건부 변형을 삽입할 수 있음을 의미합니다. :doc:`다음 페이지 <editexample6-5>`에서 이에 대해 자세히 설명합니다.


앵커링 마크
---------------

일부 스크립트(아랍어, 히브리어)는 주 텍스트 글리프 주위에 모음 기호를 배치해야 합니다. 다른 스크립트(라틴어 및 그리스어의 일부 변형)는 가능한 악센트 조합이 너무 많아 모든 조합에 대해 미리 조립된 글리프를 갖는 것이 번거롭습니다.

OpenType(MicroSoft의 TrueType 글꼴 포함)에서는 모든 기본 글리프에 마크가 부착될 위치를 표시하고 모든 마크에 기본 글리프가 부착될 위치를 표시할 수 있습니다. 따라서 소문자 a 위에 모든 악센트(양음, 억음, 움라우트, 곡절, 물결표, 장음, 고리, 곡절 등)가 부착될 위치를 나타내는 앵커를 중앙에 배치하고 모든 악센트 아래에 다른 앵커를 배치하여 두 글리프가 텍스트에서 인접할 때 워드 프로세서가 악센트를 "a" 위에 오도록 배치할 위치를 알 수 있습니다.

.. flex-grid::
   :class: flex-nobreak flex-middle

   * :flex-widths: 0 0 0 0 0

     - .. image:: /images/a_with_anchor.png
     - \+
     - .. image:: /images/grave_with_anchor.png
     - =>
     - .. image:: /images/agrave_anchored.png

모든 악센트가 문자 위에 중앙에 있는 것은 아니므로(점과 오고넥은 문자 아래에 있음) 다른 부착 스타일에 대해 둘 이상의 앵커가 필요할 수 있습니다.

마지막으로 일부 문자는 여러 개의 부착물을 가질 수 있습니다. 예를 들어 유니코드 U+1EA4는 곡절과 양음이 있는 A입니다. 일반적으로 곡절과 양음은 같은 지점에 부착되어 보기 흉하고 혼란스러울 것입니다. 대신 곡절에 다른 종류의 앵커, 즉 마크 대 마크 앵커를 만들고 양음 악센트가 거기에 부착되도록 합니다.

글리프에 앵커를 만들기 전에 (물론) 조회 및 하위 테이블을 만들어야 합니다. 이것은 또 다른 글리프 위치 지정 조회이므로 GPOS 창에 입력합니다. 하위 테이블을 만든 후에는 앵커 클래스를 묻는 다른 대화 상자가 표시됩니다. 각 부착 유형에 대해 :ref:`앵커 클래스 <overview.Anchors>`를 만들어야 합니다(따라서 두 가지 유형의 부착물이 있는 위의 A의 경우(하나는 위, 하나는 아래) 두 개의 앵커 클래스를 만듭니다).

그런 다음 부착이 이루어질 각 글리프에 대해 먼저 앵커가 생성될 지점을 클릭한 다음 :ref:`점->앵커 추가 <pointmenu.AddAnchor>` 대화 상자를 엽니다.

:ref:`보기->앵커 제어... <viewmenu.AControl>` 명령을 사용하여 글리프가 결합하는 다른 글리프에 어떻게 맞는지 검사(및 수정)할 수 있습니다.

.. warning::

   **마크 부착에 대한 경고:** 모든 소프트웨어가 이를 지원하는 것은 아닙니다. 그리고 더 혼란스럽게도 소프트웨어는 일부 스크립트에서는 지원하고 다른 스크립트에서는 지원하지 않을 수 있습니다.
