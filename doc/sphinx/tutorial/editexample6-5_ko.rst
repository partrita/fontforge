조건부 기능
====================

OpenType과 Apple 글꼴 모두 문맥적 기능을 제공합니다. 이것은 주어진 문맥에서만 발생하는 기능이며 인도어와 아랍어 스크립트를 조판하는 데 필수적입니다. OpenType에서 문맥은 문서의 글리프 스트림에 대해 테스트되는 패턴 집합으로 지정됩니다. 패턴이 일치하면 정의된 모든 대체가 적용됩니다. Apple 글꼴에서 문맥은 상태 기계, 즉 글리프 스트림을 구문 분석하고 변환하는 미니 프로그램으로 지정됩니다.

조건부 기능에는 대체, 합자 또는 커닝(그리고 일부 더 모호한 동작)이 포함될 수 있습니다. 먼저 문맥적 대체 예제를 제공하고 나중에 :ref:`문맥적 합자 <editexample6-5.Greek>` 예제를 제공하겠습니다.

.. image:: /images/bed-script.png
   :align: right

인도어 또는 아랍어 예제 대신 제가 더 익숙한 라틴어 스크립트 글꼴 조판 문제를 예로 들어 보겠습니다. 여기서 문자 "b", "o", "v", "w"는 x-높이 근처에서 다음 문자와 결합하고 다른 모든 문자는 기준선 근처에서 결합합니다. 따라서 각 글리프에는 두 가지 변형이 필요합니다. 하나는 기준선(기본 변형)에서 (왼쪽으로) 결합하는 것이고 다른 하나는 x-높이에서 결합하는 것입니다. 이 두 번째 문자 집합을 "높은" 문자라고 부르고 "a.high", "b.high" 등으로 이름을 지정합시다.


OpenType 예제
----------------

.. warning::

   다음 예제는 작동하지 않을 수 있습니다! 그것에 의해 생성된 글꼴 테이블은 모두 정확하지만 OpenType의 초기 구현에서는 라틴어 스크립트에 대한 "문맥적 대안"('calt') 기능을 지원하지 않았습니다.

   작동하지 않을 수 있는 예제를 왜 제공하나요? 제가 할 수 있는 최선입니다. 인도어 또는 아랍어 조판에 대해 충분히 알았다면 해당 스크립트에 대한 예제를 제공했을 것입니다. 하지만 저는 모릅니다. 절차는 동일합니다. 다른 스크립트에 대해 따르면 작동할 것입니다.

   시간이 지남에 따라 'calt'는 latn에 대한 더 많은 응용 프로그램에서 지원되었으며 이 경고는 예전만큼 적용되지 않습니다.

우리는 가능한 글리프 집합을 세 가지 클래스로 나눕니다. 문자 "bovw", 다른 모든 문자, 다른 모든 글리프. 두 가지 패턴을 만들어야 합니다. 첫 번째 패턴은 "bovw" 클래스의 글리프와 "bovw" 클래스의 다른 글리프가 뒤따르는 것을 일치시키고, 두 번째 패턴은 "bovw" 클래스의 글리프와 다른 모든 문자가 뒤따르는 것을 일치시킵니다. 이 중 하나라도 일치하면 두 번째 글리프는 높은 변형으로 변환되어야 합니다.

* [bovw] [bovw] => 두 번째 문자에 대체 적용
* [bovw] <다른 모든 문자> => 두 번째 문자에 대체 적용

(왜 모든 문자로 구성된 클래스를 하나만 사용하고 두 개 대신 하나의 규칙을 사용하지 않는지 궁금할 수 있습니다. 왜냐하면 이 경우 모든 클래스는 서로 배타적이어야 하고, 하나의 글리프가 두 클래스에 나타날 수 없기 때문입니다.)

가장 먼저 해야 할 일은 각 낮은 문자를 높은 변형에 매핑하는 간단한 대체를 만드는 것입니다. 이것은 "단순 대체" 조성이지만 어떤 기능에도 연결되지 않고 대신 문맥적 조성에 의해 호출됩니다. 이 조성을 "높음"이라고 부릅시다. 물론 조성과 함께 하위 테이블을 만들어야 하고, [접미사로 기본값:] 버튼을 사용하여 높은 변형으로 채울 수 있습니다.

까다로운 부분은 문맥을 정의하는 것입니다. 이것은 'calt' 기능과 연결되어야 하는 또 다른 조성, 즉 문맥적 체인 조성을 정의하여 수행됩니다. 그리고 물론 관련 하위 테이블이 필요합니다. 그러면 문맥적 하위 테이블을 편집하기 위한 일련의 대화 상자가 나타납니다.

.. image:: /images/contextchain-format.png
   :align: left

첫 번째 대화 상자에서는 대체 전체 형식을 지정할 수 있습니다. 우리는 클래스 기반 시스템을 원합니다. 글리프 클래스가 무엇인지 이미 언급했습니다.

.. image:: /images/contextchain-simpleclasses.png
   :align: right

다음 대화 상자는 마침내 흥미로운 것을 보여줍니다. 위에는 일치시킬 패턴과 문자열이 일치할 경우 적용될 대체가 있습니다. 그 아래에는 이 대체가 사용하는 글리프 클래스가 있습니다. 문맥적 체인 대화 상자는 글리프 스트림을 세 부분으로 나눕니다. 현재 글리프 이전의 글리프(이것을 역추적 글리프라고 함), 간단한 대체가 적용될 수 있는 현재 글리프 자체, 그리고 마지막으로 현재 글리프 이후의 글리프(이것을 미리보기 글리프라고 함)입니다.

각 글리프 범주는 글리프를 다른 클래스 집합으로 나눌 수 있지만 이 예에서는 모든 범주에 대해 동일한 클래스를 사용합니다(이렇게 하면 대체를 Apple 형식으로 변환하기가 더 쉬워짐). "일치 규칙" 필드의 첫 번째 줄은 다음과 같이 읽어야 합니다. 역추적 글리프("높음-다음" 클래스)가 "문자" 클래스의 현재 글리프로 이어지면 일치 문자열의 해당 문자(즉, 현재 글리프)에 "To-TopJoin"이라는 간단한 대체가 적용되어야 합니다.

글리프 클래스 정의를 보면 "높음-다음" 클래스에 높은 변형이 뒤따라야 하는 글리프가 포함되어 있으므로 이것은 합리적으로 보입니다.

이제 위에서 언급한 두 번째 경우를 처리하기 위해 ``"높음-다음 | 높음-다음 @<To-TopJoin> |"``과 같은 두 번째 줄이 있어야 합니다. 불행히도 그것은 작동하지 않는 것 같습니다. OpenType 사양에서는 허용하지만 OpenType 구현에서는 지원하지 않는 것 같습니다. 대신 해당 줄은 동일한 조회 내의 별도 하위 테이블에 있어야 합니다.

글리프 클래스를 편집하려면 클릭하고 입력하기만 하면 됩니다. 새 클래스를 만들려면 목록 하단의 <새로 만들기> 버튼을 누릅니다. 오른쪽에 있는 작은 상자 모양을 클릭할 수도 있습니다. 그러면 글꼴 보기를 보여주는 다른 대화 상자가 나타납니다. 글꼴 보기에서 글리프를 선택하는 것이 이름을 기억하는 것보다 쉬우면 선택할 수 있습니다.

명백한 방법으로 패턴을 편집할 수 있습니다. 글리프 이름을 입력하면 자동으로 완성됩니다. 패턴 목록 하단에는 두 개의 버튼이 있습니다. 하나는 새 섹션을 시작하는 것(역추적에서 활성으로 또는 활성에서 미리보기로 이동)이고 다른 하나는 새 조회 참조를 추가하는 것입니다.

.. warning::

   **문맥적 동작에 대한 경고:** 모든 소프트웨어가 이를 지원하는 것은 아닙니다. 그리고 더 혼란스럽게도 소프트웨어는 일부 스크립트에서는 지원하고 다른 스크립트에서는 지원하지 않을 수 있습니다.


.. _editexample6-5.Apple:

Apple 고급 타이포그래피
-------------------------

Apple은 상태 머신으로 문맥을 지정하는데, 이는 본질적으로 글리프 스트림을 보고 어떤 대체를 적용할지 결정하는 작은 프로그램입니다. 각 상태 머신에는 글리프 클래스 정의 집합(OpenType 예제와 마찬가지로)과 상태 집합이 있습니다. 프로세스는 글리프 스트림 시작 부분의 상태 0에서 시작됩니다. 컴퓨터는 현재 글리프가 어떤 클래스에 있는지 확인한 다음 현재 상태를 보고 해당 클래스의 입력을 받았을 때 어떻게 동작할지 확인합니다. 동작에는 다른 상태로 변경하는 기능, 입력을 다음 글리프로 진행하는 기능, 현재 글리프 또는 이전 글리프("표시된" 글리프)에 대체를 적용하는 기능이 포함됩니다.

.. image:: /images/sm-picture.png
   :align: right

라틴어 스크립트 글꼴의 동일한 예제를 사용하여... 다시 각 문자를 높은 대체 문자로 변환하기 위한 간단한 대체가 필요합니다. 프로세스는 OpenType과 동일하며 실제로 동일한 대체를 사용할 수 있습니다. 다시 글리프를 세 가지 클래스로 나눕니다(Apple은 원하든 원치 않든 몇 가지 추가 클래스를 제공하지만 개념적으로는 OpenType 예제와 동일한 세 가지 클래스를 사용합니다). 두 가지 상태가 있는 상태 머신이 필요합니다(다시 Apple은 무료로 추가 상태를 제공하지만 무시하겠습니다). 하나는 시작 상태(기본 상태 -- 아무것도 변경되지 않음)이고 다른 하나는 "bovw" 클래스의 글리프를 방금 읽은 상태입니다.

.. image:: /images/asm1.png
   :align: left

Apple 고급 타이포그래피는 OpenType의 조회 및 기능 개념에 완전히 들어맞지는 않지만, 제가 강제로 맞추기에는 충분히 가깝습니다. 그래서 다시 GSUB 조회를 만듭니다. 이번에는 조회 유형이 "Mac 문맥적 상태 머신"이고 기능은 실제로 Mac 기능/설정, 즉 두 개의 숫자입니다. 이 유형의 새 하위 테이블을 만들면 아래와 같이 상태 머신 대화 상자가 나타납니다.

.. image:: /images/asm2.png
   :align: right

대화 상자 상단에는 클래스 정의 집합이 있고 하단에는 상태 머신 자체의 표현이 있습니다.

.. image:: /images/asm3.png
   :align: left

클래스를 두 번 클릭하면 OpenType에서 사용된 것과 유사한 대화 상자가 나타납니다.

.. image:: /images/asm4.png
   :align: right

상태 머신에서 전환을 클릭하면(각 상태/클래스 조합에 대해 전환이 있음) 전환 대화 상자가 나타납니다. 이것은 상태 머신이 주어진 상태에 있고 주어진 클래스의 글리프를 받았을 때 어떻게 동작하는지 제어합니다. 이 예에서는 상태 2에 있습니다(즉, "bovw" 글리프를 이미 읽었음). 그리고 클래스 4의 글리프를 받았습니다(이것은 또 다른 "bovw" 글리프임). 이 경우 다음 상태는 다시 상태 2가 되고(새 "bovw" 글리프를 방금 읽었음), 다른 글리프를 읽고 현재 글리프에 "높은" 대체를 적용합니다.

대화 상자 하단에는 상태 머신의 전환을 탐색할 수 있는 일련의 버튼이 있습니다.

[확인]을 여러 번 누르면 이 대화 상자 체인에서 빠져나와 글꼴에 새 상태 머신을 추가합니다.


.. _editexample6-5.Greek:

OpenType, 그리스어 합자
-------------------------

그리스어에는 라틴어 앰퍼샌드에 해당하는 문자(U+03D7)가 있습니다. 앰퍼샌드가 원래 "E"와 "t"의 합자인 것처럼 U+03D7은 "카파"와 "요타"의 합자입니다. 그러나 이 합자는 "카파"와 "요타"가 단독으로 단어를 구성하는 경우에만 사용해야 하며, 더 긴 단어 내에서 두 문자가 더 일반적으로 나타나는 경우에는 사용해서는 안 됩니다.

.. image:: /images/kappa_iota-lookup.png
   :align: right

따라서 가장 먼저 해야 할 일은 합자 자체를 만드는 것입니다. U+03D7에 대한 글리프를 추가한 다음 :ref:`요소->글꼴 정보->조회 <fontinfo.Lookups>`를 사용하여 U+03D7을 "카파"와 "요타"의 합자로 바인딩하는 합자 조회 및 하위 테이블을 만듭니다. 이 조회는 직접 사용되지 않고 다른 조건부 기능의 제어 하에서만 사용되므로 기능 태그를 부여하지 않습니다.

.. image:: /images/kappa_iota-subtable.png

다음은 조건부 비트입니다.

저는 모든 그리스 문자로 구성된 클래스를 나타내기 위해 <문자> 표기법을 사용할 것입니다.

#. <문자> 카파 요타 => 대체 없음
#. 카파 요타 <문자> => 대체 없음
#. 카파 요타 => 합자 "WORD" 적용

:small:`(이제 표준을 읽으면서 이 모든 규칙을 하나의 하위 테이블에 넣을 수 있고 제가 가진 글꼴 유효성 검사 도구도 동의하지만 레이아웃 엔진은 동의하지 않습니다. 레이아웃 엔진은 각 규칙이 자체 하위 테이블에 있어야 한다고 주장하는 것 같습니다. 이것은 불편하지만(클래스는 각 하위 테이블에 정의되어야 함) 작동하는 것 같습니다.)`

이러한 규칙은 순서대로 실행되며 입력 텍스트와 일치하는 첫 번째 규칙이 적용되는 (유일한) 규칙이 됩니다. 다음 세 문자열을 고려하십시오. :math:`\alpha\kappa\iota`, :math:`\kappa\iota\theta`, :math:`\alpha\kappa\iota\theta` 모두 카파와 요타를 포함하지만 각각 주위에 더 많은 문자가 있으므로 어느 것도 합자로 대체되어서는 안 됩니다.

* 첫 번째 문자열 :math:`\alpha\kappa\iota`는 위 첫 번째 규칙과 일치하며(카파 요타 시퀀스 앞에 문자가 포함됨) 대체가 수행되지 않습니다. 세 번째 규칙과도 일치하지만 거기까지 가지 않습니다.
* 두 번째 문자열 :math:`\kappa\iota\theta`는 위 두 번째 규칙과 일치하며(시퀀스 뒤에 문자가 포함됨) 다시 대체가 수행되지 않습니다. 세 번째 규칙과 일치하지만 첫 번째 일치에서 멈춥니다.
* 세 번째 문자열 :math:`\alpha\kappa\iota\theta`는 모든 규칙과 일치하지만 검색이 첫 번째 일치에서 멈추므로 첫 번째 규칙만 적용되고 대체가 수행되지 않습니다.
* 문자열 :math:`\_\kappa\iota\_`는 처음 두 규칙 중 어느 것과도 일치하지 않지만 마지막 규칙과 일치하므로 여기서 합자가 형성됩니다.

왜 하나의 규칙만 사용하지 않는지 궁금할 수 있습니다.

#. <모든 비문자> 카파 요타 <모든 비문자> => 합자 적용

훨씬 간단해 보입니다.

음, 한 가지 주요 이유가 있습니다.

* 이것은 카파가 입력 스트림의 시작 부분에 있는 경우(앞에 글리프가 없지만 여전히 교체해야 할 수 있음) 또는 요타가 끝에 있는 경우 작동하지 않습니다.

이제 이러한 규칙을 문맥적 조회로 어떻게 변환할까요?

.. image:: /images/kappa_iota-context.png
   :align: left

:doc:`요소->글꼴 정보->조회->조회 추가 </ui/dialogs/lookups>`를 사용하여 새 문맥적 체인 조회를 만듭니다. 이것은 최상위 조회이며 그리스어 스크립트의 기능 태그에 바인딩되어야 합니다.

우리는 세 가지 규칙을 가지고 있으며 각 규칙은 자체 하위 테이블에 있습니다. 따라서 각각에 대해 하나씩 세 개의 하위 테이블을 만듭니다. 조회 창에서 이러한 하위 테이블의 순서는 중요합니다. 왜냐하면 포함된 규칙이 실행되는 순서이기 때문입니다. 합자를 실제로 호출하는 최종 규칙이 마지막으로 실행되고 목록의 마지막에 있는지 확인해야 합니다.

.. rubric:: 단계

.. image:: /images/hligbyclasses.png

모든 그리스 문자로 구성된 클래스를 사용할 계획이므로 이 기능에 대해 클래스 형식을 사용하고 싶을 것입니다. 그런 다음 ``[다음>]`` 버튼을 누릅니다.

.. image:: /images/emptyhlig.png

주요 일치는 세 가지 규칙 모두에서 문자 카파와 요타에 대한 것이므로 각각에 대해 하나의 클래스가 필요합니다. 따라서 일치 클래스 영역에서 ``[새로 만들기]`` 버튼을 누릅니다...

.. image:: /images/hligkappaclass.png

그리고 "카파"라는 단어를 입력하고 ``[다음>]``을 누릅니다.

.. image:: /images/hligkappa.png

이제 단일 글리프 "카파"를 포함하는 클래스가 있습니다. "요타"에 대해서도 동일한 작업을 수행하고 싶으므로 ``[새로 만들기]``를 다시 누릅니다.

.. image:: /images/hligiotaclass.png

다시 "요타"를 입력하고 ``[다음>]``을 누릅니다.

.. image:: /images/hligkappaiota.png

이제 여기에 필요한 모든 클래스가 있습니다. 여전히 미리보기 및 역추적에 대한 클래스를 만들어야 합니다. 이러한 그룹에 대해 하나의 클래스만 필요하며 해당 클래스는 모든 그리스 문자로 구성됩니다.

.. image:: /images/hligback.png

``[*] 일치 클래스와 동일`` 확인란이 설정되어 있지만 우리는 그것을 원하지 않습니다. 여기에 우리 자신의 클래스를 원합니다. 따라서 선택을 취소합니다.

.. image:: /images/hligbacknomatch.png

이제 버튼이 활성화되고 ``[새로 만들기]``를 눌러 새 클래스를 만들 수 있습니다.

.. image:: /images/allgreek.png

이제 글꼴 보기로 돌아가서 모든 그리스 문자를 선택한 다음 클래스 대화 상자에서 [글꼴에서 설정] 버튼을 누를 수 있습니다.

.. image:: /images/hliggreekclass.png

하지만 이 경우 우리가 관심 있는 클래스(모든 그리스 문자)는 내장되어 있으며 표준 클래스 풀다운 목록(스크립트의 문자)에서 선택할 수 있습니다. 그런 다음 ``[다음>]``을 누릅니다.

.. flex-grid::

   * - .. image:: /images/hliggreekback.png
     - .. image:: /images/hliggreekahead.png

그런 다음 미리보기 클래스에 대해 동일한 프로세스를 거칩니다(모든 그리스 문자로 구성된 하나의 클래스 추가).

.. image:: /images/hlignewrule.png

이제 모든 클래스가 정의되었고 마침내 규칙에 대한 패턴을 만들 준비가 되었습니다. 따라서 "클래스 번호 목록 목록" 아래에서 ``[새로 만들기]`` 버튼을 누릅니다.

.. image:: /images/hligbackrule.png

첫 번째 규칙은 역추적 영역의 모든 그리스 문자로 시작하므로 "역추적" 탭을 클릭한 다음 모든 그리스 문자로 구성된 클래스를 클릭합니다. 그러면 클래스 번호가 패턴 영역(클래스 번호 목록)에 들어갑니다.

.. image:: /images/hligrule.png

일치 영역에서 카파와 요타를 일치시키고 싶으므로 일치 탭을 클릭한 다음 "카파"와 "요타" 항목을 클릭합니다.

이 규칙에는 대체가 없으므로 아래 영역을 비워두고 ``[다음>]``을 누릅니다.

.. image:: /images/hligbackruledone.png

첫 번째 규칙이 완료되었습니다. 내용은 다음과 같습니다.

* 이전 문자는 역추적 클래스의 클래스 1과 일치해야 합니다(그리고 해당 클래스에는 모든 그리스 문자가 포함되어 있으므로 원하는 것입니다).
* 현재 문자는 일치 클래스의 클래스 1과 일치해야 합니다(그리고 해당 클래스에는 "카파"가 포함됨).
* 다음 문자는 일치 클래스의 클래스 2와 일치해야 합니다(요타임).
* 그리고 일치가 성공하면 아무것도 하지 않습니다.

하지만 두 가지 규칙이 더 있으므로 ``[확인]``을 누른 다음 ``[하위 테이블 추가]``를 누릅니다. 그런 다음 모든 클래스를 추가하는 과정을 거친 다음 이 규칙에 대한 일치 문자열을 추가합니다.

.. image:: /images/hligaheadruledone.png

두 번째 규칙이 완료되었습니다. 내용은 다음과 같습니다.

* 현재 문자는 일치 클래스의 클래스 1과 일치해야 합니다(그리고 해당 클래스에는 "카파"가 포함됨).
* 다음 문자는 일치 클래스의 클래스 2와 일치해야 합니다(요타임).
* 그 다음 문자는 미리보기 클래스의 클래스 1과 일치해야 합니다(그리고 해당 클래스에는 모든 그리스 문자가 포함됨).
* 그리고 일치가 성공하면 아무것도 하지 않습니다.

최종 규칙에 대해 ``[확인]`` 및 ``[하위 테이블 추가]``를 누릅니다.

.. image:: /images/hligrule.png

이 규칙에는 대체가 있습니다. 두 문자를 가져와 합자로 변환하고 싶습니다. 따라서 시퀀스 위치 목록 아래에서 ``[새로 만들기]``를 누릅니다. 첫 번째 문자(시퀀스 위치 0)에서 시작하여 "WORD"라는 합자를 적용하고 싶습니다.

.. image:: /images/hligseqdlg.png

따라서 처음 두 규칙과 일치하지 않고 카파 뒤에 요타가 포함된 것은 두 글자로 된 독립적인 그리스어 단어여야 합니다. 그리고 우리는 거기에 합자를 적용하고 싶습니다.

.. image:: /images/hligallrulesdone.png

이제 끝났습니다. 모든 대화 상자가 수락될 때까지 일련의 ``[확인]``을 누릅니다.

.. image:: /images/kappaiota-lookups.png

조회를 만든 후에는 :doc:`메트릭 보기 </ui/mainviews/metricsview>`에서 결과를 테스트할 수 있습니다.

.. image:: /images/metrics-kappa_iota.png

(이 예제는 Apostolos Syropoulos가 제공했습니다.)
